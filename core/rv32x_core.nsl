#include "rv32x_core.h"
#include "rv32x5p.h"
#include "opcode.h"
#include "priv.h"
#include "csr.h"
#include "csr_map.h"
#include "icache_unit.h"
#include "dcache_unit.h"

#define INIT_MTVEC {30'b00000_00000_00000_00000_00000_00000, MTVEC_MODE_DIRECT}
#define MISA_EXTENSIONS MISA_EXTENSIONS_I|MISA_EXTENSIONS_M|MISA_EXTENSIONS_U

module rv32x_core {
	rv32x5p rv32x;							/* 5-stage pipelined processor(single issue, in-order) */
	icache_unit ic;
	dcache_unit dc;
	reg ic_invalidate_done = 0;
	reg dc_flush_done = 0;
	reg mode[2];							/* Current execution mode */
	
	wire ncadrs[32];
	wire ncbyteen[3];
	wire ncdata[32];
	func_self noncacheable_read(ncadrs, ncbyteen);
	func_self noncacheable_write(ncadrs, ncbyteen, ncdata);
	
	/* Trap */
	reg cause[32];
	reg epc[32];
	reg tval[32];
	reg trap_mode[2];
	proc_name trap(trap_mode, cause, epc, tval);
	proc_name trap_mret();
	proc_name trap_sret();
	proc_name trap_uret();
	/* Interrupt */
	func_self interrupt();
	func_self machine_interrupt_enabled();
	func_self supervisor_interrupt_enabled();
	func_self machine_timer_interrupt_pending();
	func_self machine_software_interrupt_pending();
	func_self machine_external_interrupt_pending();
	func_self supervisor_timer_interrupt_pending();
	func_self supervisor_software_interrupt_pending();
	func_self supervisor_external_interrupt_pending();
	/* Exceptions */
	func_self exception();
	func_self instruction_address_breakpoint_exception();
	func_self instruction_page_fault_exception();
	func_self instruction_access_fault_exception();
	func_self illegal_instruction_exception();
	func_self instruction_address_misaligned_exception();
	func_self environment_call_exception();
	func_self environment_break_exception();
	func_self load_store_amo_address_breakpoint_exception();
	func_self store_amo_address_misaligned_exception();
	func_self load_address_misaligned_exception();
	func_self store_amo_page_fault_exception();
	func_self load_page_fault_exception();
	func_self store_amo_access_fault_exception();
	func_self load_access_fault_exception();

	func_self instruction_address_breakpoint();
	func_self instruction_page_fault();
	func_self instruction_access_fault();
	func_self illegal_instruction();
	func_self instruction_address_misaligned();
	func_self environment_call();
	func_self environment_break();
	func_self load_store_amo_address_breakpoint();
	func_self store_amo_address_misaligned();
	func_self load_address_misaligned();
	func_self store_amo_page_fault();
	func_self load_page_fault();
	func_self store_amo_access_fault();
	func_self load_access_fault();
	func_self machine_timer_interrupt();
	func_self machine_external_interrupt();
	func_self machine_software_interrupt();
	func_self supervisor_timer_interrupt();
	func_self supervisor_external_interrupt();
	func_self supervisor_software_interrupt();

	wire cwadrs[32];
	wire cwdata[32];
	func_self csr_write(cwadrs, cwdata);
	wire cradrs[32];
	wire crdata[32];
	func_self csr_read(cradrs) : crdata;
	func_self csr_read_not_mapped();
	func_self csr_write_not_mapped();
#ifdef DEBUG
	reg debug_einst[32];
#endif


	/* CSRs */
	mvendorid_t reg mvendorid		= 0;
	marchid_t reg marchid			= 0;
	mimpid_t reg mimpid				= 0;
	mhartid_t reg mhartid			= 0;
	mstatus_t reg mstatus			= 0;
	mstatush_t reg mstatush			= 0;
	mtvec_t reg mtvec 				= INIT_MTVEC;
	mscratch_t reg mscratch			= 0;
	mepc_t reg mepc					= 0;
	mcause_t reg mcause 			= RESET;
	mtval_t reg mtval				= 0;
	misa_t reg misa					= 0;
	mie_t reg mie					= 0;
	mip_t reg mip					= 0;
	mideleg_t reg mideleg			= 0;
	medeleg_t reg medeleg			= 0;

	sstatus_t reg sstatus			= 0;		
	sie_t reg sie					= 0;
	stvec_t reg stvec				= 0;
	sscratch_t reg sscratch			= 0;
	sepc_t reg sepc					= 0;
	scause_t reg scause				= 0;
	stval_t reg stval 				= 0;
	sip_t reg sip					= 0;

	ustatus_t reg ustatus			= 0;
	uie_t reg uie					= 0;
	utvec_t reg utvec				= 0;
	uscratch_t reg uscratch			= 0;
	uepc_t reg uepc					= 0;
	ucause_t reg ucause				= 0;
	utval_t reg utval 				= 0;
	uip_t reg uip					= 0;

	wire msip;
	wire mtip;
	wire meip;
	wire ssip;
	wire stip;
	wire seip;
	wire usip;
	wire utip;
	wire ueip;

	wire sxlen[2];
	wire uxlen[2];
	wire ialign[2];

	reg minstret[64]				= 0;
	reg mcycle[64]					= 0;
	reg utime[64]					= 0;
	
	sxlen = MISA_MXL_32;
	uxlen = MISA_MXL_32;
	ialign = 2'b11;

	rv32x.ialign = ialign;

	if(!csr_write) {	/* precisely, !((mcycle || minstret) && csr_write) */
		mcycle++;	/* if wfi, then stop counting up */
		if(rv32x.instret) {
			minstret++;	/* not-precise, some instruction such as ecall will not retire */
		}
	}
	utime++;	/* if m_clock == 50MHz, then 1 tick is 20ns */

	/* checking !trap is required, since most of interrupt pending bits
		only be cleared from software via writing one of correspoinding
		register in PLIC, CLINT not xip registers(some may be read-only).
		Hence, until disabling xstatus.mie, interrupts pendings are handled
		many times. So check if currently handling interrupts(in trap state)
		or not.
	*/
	if(((mode < MACHINE) || ((mode == MACHINE) && mstatus.mie)) && !trap) {
		machine_interrupt_enabled();
	}
	if(((mode < SUPERVISOR) || mstatus.sie) && !trap) {
		supervisor_interrupt_enabled();
	}
	if(meip && mie.meie) {
		machine_external_interrupt_pending();
	}
	if(mtip && mie.mtie) {
		machine_timer_interrupt_pending();
	}
	if(msip && mie.msie) {
		machine_software_interrupt_pending();
	}
	if(seip && mie.seie) {
		supervisor_external_interrupt_pending();
	}
	if(stip && mie.stie) {
		supervisor_timer_interrupt_pending();
	}
	if(ssip && mie.ssie) {
		supervisor_software_interrupt_pending();
	}

	msip = (machine_software_interrupt_req & ~mideleg.msip);
	mtip = (machine_timer_interrupt_req & ~mideleg.mtip);
	meip = (machine_external_interrupt_req & ~mideleg.meip);
	ssip = ((supervisor_software_interrupt_req | mip.ssip) | (machine_software_interrupt_req & mideleg.msip));
	stip = ((supervisor_timer_interrupt_req | mip.stip) | (machine_timer_interrupt_req & mideleg.mtip));
	seip = ((supervisor_external_interrupt_req | mip.seip) | (machine_external_interrupt_req & mideleg.meip));

	func reset {
		wire resetvector[32];

		mode 						:= MACHINE;
		mstatus.mie 				:= 0;
		mstatus.mprv 				:= 0;
		mstatush.mbe				:= 0;
		mstatus.mpp					:= MACHINE;
		misa.mxl 					:= MISA_MXL_32;
		misa.extensions 			:= MISA_EXTENSIONS;
		mcause 						:= RESET;
		mtvec 						:= INIT_MTVEC;

		ic.reset();
		dc.reset();
		resetvector = {mtvec.base, 2'b00};	/* Shynchronous execption(RESET) */
		rv32x.reset(resetvector);
	}
	/* CSR accesses */
	func rv32x.csr_read {
		if(csr_read_not_mapped) {
			illegal_instruction();
		}
		return csr_read(rv32x.cradrs);
	}
	func csr_read {
		any {
			/* Machine-mode */
			(mode >= MACHINE) && cradrs == MVENDORID:		return mvendorid;
			(mode >= MACHINE) && cradrs == MARCHID:			return marchid;
			(mode >= MACHINE) && cradrs == MIMPID:			return mimpid;
			(mode >= MACHINE) && cradrs == MHARTID:			return mhartid;
			(mode >= MACHINE) && cradrs == MSTATUS:			return mstatus;
			(mode >= MACHINE) && cradrs == MISA:			return misa;
			(mode >= MACHINE) && cradrs == MEDELEG:			return medeleg;
			(mode >= MACHINE) && cradrs == MIDELEG:			return mideleg;
			(mode >= MACHINE) && cradrs == MIE:				return mie;
			(mode >= MACHINE) && cradrs == MTVEC:			return mtvec;
			//(mode >= MACHINE) && cradrs == MCOUNTEREN:	return mcounteren;
			(mode >= MACHINE) && cradrs == MSTATUSH:		return mstatush;
			(mode >= MACHINE) && cradrs == MSCRATCH:		return mscratch;
			(mode >= MACHINE) && cradrs == MEPC:			return mepc;
			(mode >= MACHINE) && cradrs == MCAUSE:			return mcause;
			(mode >= MACHINE) && cradrs == MTVAL:			return mtval;
			(mode >= MACHINE) && cradrs == MIP:				return mip | 32'({meip, 1'b1, seip, ueip, mtip, 1'b0, stip, utip, msip, 1'b0, ssip, usip});
			//(mode >= MACHINE) && cradrs == MTINST:		return mtinst;
			//(mode >= MACHINE) && cradrs == MTVAL2:		return mtval2;
			/* Machine Memory Protection */
			/* Machine Counter/Timers */
			(mode >= MACHINE) && cradrs == MCYCLEH:			return mcycle[63:32];
			(mode >= MACHINE) && cradrs == MCYCLE:			return mcycle[31:0];
			(mode >= MACHINE) && cradrs == MINSTRETH:		return minstret[63:32];
			(mode >= MACHINE) && cradrs == MINSTRET:		return minstret[31:0];

			/* Supervisor-mode */
			(mode >= SUPERVISOR) && cradrs == SSTATUS:		return sstatus;
			//(mode >= SUPERVISOR) && cradrs == SEDELEG:	return sedeleg;
			//(mode >= SUPERVISOR) && cradrs == SIDELEG:	return sideleg;
			(mode >= SUPERVISOR) && cradrs == SIE:		return sie;
			(mode >= SUPERVISOR) && cradrs == STVEC:		return stvec;
			//(mode >= SUPERVISOR) && cradrs == SCOUNTEREN:	return scounteren;
			(mode >= SUPERVISOR) && cradrs == SSCRATCH:		return sscratch;
			(mode >= SUPERVISOR) && cradrs == SEPC:			return sepc;
			(mode >= SUPERVISOR) && cradrs == SCAUSE:		return scause;
			(mode >= SUPERVISOR) && cradrs == STVAL:		return stval;
			(mode >= SUPERVISOR) && cradrs == SIP:		return sip;
			//(mode >= SUPERVISOR) && cradrs == SATP:		return stap;

			/* User-mode */
			(mode >= USER) && cradrs == USTATUS:			return ustatus;
			(mode >= USER) && cradrs == UIE:				return uie;
			(mode >= USER) && cradrs == UTVEC:				return utvec;
			(mode >= USER) && cradrs == USCRATCH:			return uscratch;
			(mode >= USER) && cradrs == UEPC:				return uepc;
			(mode >= USER) && cradrs == UCAUSE:				return ucause;
			(mode >= USER) && cradrs == UTVAL:				return utval;
			(mode >= USER) && cradrs == UIP:				return uip;
			//(mode >= USER) && cradrs == FFLAGS:			return fflags;
			//(mode >= USER) && cradrs == FRM:				return frm;
			//(mode >= USER) && cradrs == FCSR:				return fcsr;
			/* User Counter/Timers */
			(mode >= USER) && cradrs == CYCLEH:				return mcycle[63:32];
			(mode >= USER) && cradrs == CYCLE:				return mcycle[31:0];
			(mode >= USER) && cradrs == INSTRETH:			return minstret[63:32];
			(mode >= USER) && cradrs == INSTRET:			return minstret[31:0];
			(mode >= USER) && cradrs == TIMEH:				return utime[63:32];
			(mode >= USER) && cradrs == TIME:				return utime[31:0];
			else:											{csr_read_not_mapped(); return 0x00000000;}
		}
	}
	func rv32x.csr_write {
		if(rv32x.csr_write_uimm) {
			csr_write(rv32x.cwadrs, {csr_read(rv32x.cwadrs)[31:5], rv32x.cwdata[4:0]});
		} else {
			csr_write(rv32x.cwadrs, rv32x.cwdata);
		}
		if(csr_write_not_mapped) {
			illegal_instruction();
		}
	}

	func csr_write {
		mstatus_t wire status_w; 
		mtvec_t  wire tvec_w;
		mip_t wire ip_w;
		mideleg_t wire ideleg_w;
		medeleg_t wire edeleg_w;
		mie_t wire ie_w;

		any {
			(mode >= MACHINE) && cwadrs == MSTATUS: {
				status_w = cwdata;
				
				//mstatus.sd := status_w.sd;
				//mstatus.tsr := status_w.tsr;
				//mstatus.tw := status_w.tw;
				//mstatus.tvm := status_w.tvm;
				//mstatus.mxr := status_w.mxr;
				//mstatus.sum := status_w.sum;
				mstatus.mprv := status_w.mprv;
				//mstatus.xs := status_w.xs;
				//mstatus.fs := status_w.fs;
				mstatus.mpp := if(status_w.mpp == USER || status_w.mpp == MACHINE) status_w.mpp else mstatus.mpp;
				mstatus.spp := status_w.spp;
				mstatus.mpie := status_w.mpie;
				//mstatus.ube := status_w.ube;
				mstatus.spie := status_w.spie;
				mstatus.mie := status_w.mie;
				mstatus.sie := status_w.sie;
				mstatus.uie := status_w.uie;
				mstatus.upie := status_w.upie;
				ustatus.uie := status_w.uie;
				ustatus.upie := status_w.upie;
			}
			(mode >= MACHINE) && cwadrs == MEDELEG: {
				edeleg_w = cwdata;

				medeleg.environment_call_from_u_mode := edeleg_w.environment_call_from_u_mode;
				medeleg.environment_call_from_s_mode := edeleg_w.environment_call_from_s_mode;
			}
			(mode >= MACHINE) && cwadrs == MIDELEG: {
				ideleg_w = cwdata;

				mideleg.meip := ideleg_w.meip;
				mideleg.mtip := ideleg_w.mtip;
				mideleg.msip := ideleg_w.msip;
			}
			(mode >= MACHINE) && cwadrs == MIE: {
				ie_w = cwdata;

				/* Machine mode */
				mie.meie := ie_w.meie;
				mie.mtie := ie_w.mtie;
				mie.msie := ie_w.msie;

				/* Supervisor mode */
				mie.seie := ie_w.seie;
				mie.stie := ie_w.stie;
				mie.ssie := ie_w.ssie;
				sie.seie := ie_w.seie;
				sie.stie := ie_w.stie;
				sie.ssie := ie_w.ssie;

				/* User mode */
				mie.ueie := ie_w.ueie;
				mie.utie := ie_w.utie;
				mie.usie := ie_w.usie;
				sie.ueie := ie_w.ueie;
				sie.utie := ie_w.utie;
				sie.usie := ie_w.usie;
				uie.ueie := ie_w.ueie;
				uie.utie := ie_w.utie;
				uie.usie := ie_w.usie;
			}
			(mode >= MACHINE) && cwadrs == MTVEC: {
				tvec_w = cwdata;
				
				mtvec.base := tvec_w.base;
				if(tvec_w.mode < 2'b10) {
					mtvec.mode := tvec_w.mode;
				}
			}
			(mode >= MACHINE) && cwadrs == MSTATUSH:	mstatush := cwdata & 0x00000000;
			(mode >= MACHINE) && cwadrs == MSCRATCH:	mscratch := cwdata;
			(mode >= MACHINE) && cwadrs == MEPC:		mepc := {cwdata[31:2], (cwdata[1:0] & ~ialign)};
			(mode >= MACHINE) && cwadrs == MCAUSE:		mcause := mcause;
			(mode >= MACHINE) && cwadrs == MTVAL:		mtval := cwdata;
			(mode >= MACHINE) && cwadrs == MIP: {
				ip_w = cwdata;
				
				/* mip.meip, mip.mtip, mip.msip is read-only */
				/* Only interrupt controller can set or reset */
				/* Supervisor mode */
				mip.ssip := ip_w.ssip;
				mip.seip := ip_w.seip;
				mip.stip := ip_w.stip;
				sip.ssip := ip_w.ssip;
				sip.seip := ip_w.seip;
				sip.stip := ip_w.stip;

				/* User mode */
				mip.usip := ip_w.usip;
				mip.ueip := ip_w.ueip;
				mip.utip := ip_w.utip;
				sip.usip := ip_w.usip;
				sip.ueip := ip_w.ueip;
				sip.utip := ip_w.utip;
				uip.usip := ip_w.usip;
				uip.ueip := ip_w.ueip;
				uip.utip := ip_w.utip;
			}
			(mode >= MACHINE) && cradrs == MCYCLE:			mcycle	:= {mcycle[63:32], cwdata};
			(mode >= MACHINE) && cradrs == MINSTRET:		minstret := {minstret[63:32], cwdata};
			(mode >= MACHINE) && cradrs == MCYCLEH:			mcycle	:= {cwdata, mcycle[31:0]};
			(mode >= MACHINE) && cradrs == MINSTRETH:		minstret := {cwdata, minstret[31:0]};

			(mode >= SUPERVISOR) && cwadrs == STVEC: {
				tvec_w = cwdata;
				
				stvec.base := tvec_w.base;
				if(tvec_w.mode < 2'b10) {
					stvec.mode := tvec_w.mode;
				}
			}
			(mode >= SUPERVISOR) && cwadrs == SIE: {
				ie_w = cwdata;
				
				mie.seie := ie_w.seie;
				mie.stie := ie_w.stie;
				mie.ssie := ie_w.ssie;
				sie.seie := ie_w.seie;
				sie.stie := ie_w.stie;
				sie.ssie := ie_w.ssie;

				mip.usip := ip_w.usip;
				mip.ueip := ip_w.ueip;
				mip.utip := ip_w.utip;
				sip.usip := ip_w.usip;
				sip.ueip := ip_w.ueip;
				sip.utip := ip_w.utip;
				uip.usip := ip_w.usip;
				uip.ueip := ip_w.ueip;
				uip.utip := ip_w.utip;
			}
			(mode >= SUPERVISOR) && cwadrs == SIP: {
				ip_w = cwdata;

				mip.ssip := ip_w.ssip;
				sip.ssip := ip_w.ssip;

				mip.usip := ip_w.usip;
				sip.usip := ip_w.usip;
				uip.usip := ip_w.usip;
			}
			(mode >= SUPERVISOR) && cwadrs == SSCRATCH:	sscratch := cwdata;

			(mode >= USER) && cwadrs == USTATUS: {
				status_w = cwdata;

				mstatus.uie := status_w.uie;
				mstatus.upie := status_w.upie;
				sstatus.uie := status_w.uie;
				sstatus.upie := status_w.upie;
				ustatus.uie := status_w.uie;
				ustatus.upie := status_w.upie;
			}
			(mode >= USER) && cwadrs == UIE: {
				ie_w = cwdata;

				mie.ueie := ie_w.ueie;
				mie.utie := ie_w.utie;
				mie.usie := ie_w.usie;
				sie.ueie := ie_w.ueie;
				sie.utie := ie_w.utie;
				sie.usie := ie_w.usie;
				uie.ueie := ie_w.ueie;
				uie.utie := ie_w.utie;
				uie.usie := ie_w.usie;
			}
			(mode >= USER) && cwadrs == UTVEC: {
				tvec_w = cwdata;
				
				utvec.base := tvec_w.base;
				if(tvec_w.mode < 2'b10) {
					utvec.mode := tvec_w.mode;
				}
			}
			(mode >= USER) && cwadrs == USCRATCH:		uscratch := cwdata;
			(mode >= USER) && cwadrs == UEPC:			uepc := cwdata;
			(mode >= USER) && cwadrs == UCAUSE:			ucause := cwdata;
			(mode >= USER) && cwadrs == UTVAL:			utval := cwdata;
			(mode >= USER) && cwadrs == UIP: {
				ip_w = cwdata;

				mip.usip := ip_w.usip;
				sip.usip := ip_w.usip;
				uip.usip := ip_w.usip;
			}
			else: csr_write_not_mapped();
		}
#ifdef DEBUG
		debug_csr_write(rv32x.cwadrs, rv32x.cwdata);
#endif
	}
	func rv32x.ecall {
		environment_call();
	}
	func rv32x.ebreak {
		environment_break();
	}
	func rv32x.illegal_instruction {
		illegal_instruction();
	}
	func rv32x.instruction_address_misaligned {
		instruction_address_misaligned();
	}
	func rv32x.store_address_misaligned {
		store_amo_address_misaligned();
	}
	func rv32x.load_address_misaligned {
		load_address_misaligned();
	}
	alt {
		/* Interrupt has higher priorities than exceptions */
		machine_interrupt_enabled && machine_external_interrupt_pending:		machine_external_interrupt();
		machine_interrupt_enabled && machine_software_interrupt_pending:		machine_software_interrupt();
		machine_interrupt_enabled && machine_timer_interrupt_pending:			machine_timer_interrupt();
		supervisor_interrupt_enabled && supervisor_external_interrupt_pending:	supervisor_external_interrupt();
		supervisor_interrupt_enabled && supervisor_software_interrupt_pending:	supervisor_software_interrupt();
		supervisor_interrupt_enabled && supervisor_timer_interrupt_pending:		supervisor_timer_interrupt();
		/* Process exception in preceeding instruction in pipeline */	
		/* Memory stage */
		/* memory address is sent out to bus in memory stage process load_store_amo_address_breakpoint at memory stage */
		load_store_amo_address_breakpoint:							load_store_amo_address_breakpoint_exception();
		store_amo_address_misaligned:								store_amo_address_misaligned_exception();
		load_address_misaligned:									load_address_misaligned_exception();
		store_amo_page_fault:										store_amo_page_fault_exception();
		load_page_fault:											load_page_fault_exception();
		store_amo_access_fault:										store_amo_access_fault_exception();
		load_access_fault:											load_access_fault_exception();
		/* Execute stage */
		instruction_address_misaligned:								instruction_address_misaligned_exception();	
		illegal_instruction:										illegal_instruction_exception();
		environment_call:											environment_call_exception();	
		environment_break:											environment_break_exception();	
		/* Ifetch stage */
		instruction_address_breakpoint:								instruction_address_breakpoint_exception();
		instruction_page_fault:										instruction_page_fault_exception();
		instruction_access_fault:									instruction_access_fault_exception();
	}
	func interrupt {
		rv32x.stall_ifetch_req();
		rv32x.stall_decode_req();
		rv32x.stall_execute_req();
		rv32x.flush_ifetch();
		rv32x.flush_decode();
		rv32x.flush_execute();
		rv32x.get_pc_execute();
	}
	func machine_external_interrupt {
		interrupt();
		trap(MACHINE, MACHINE_EXTERNAL_INTERRUPT, rv32x.epc, 0x00000000);
	}
	func machine_software_interrupt {
		interrupt();
		trap(MACHINE, MACHINE_SOFTWARE_INTERRUPT, rv32x.epc, 0x00000000);
	}
	func machine_timer_interrupt {
		interrupt();
		trap(MACHINE, MACHINE_TIMER_INTERRUPT, rv32x.epc, 0x00000000);
	}
	func supervisor_external_interrupt {
		interrupt();
		trap(SUPERVISOR, SUPERVISOR_EXTERNAL_INTERRUPT, rv32x.epc, 0x00000000);
	}
	func supervisor_software_interrupt {
		interrupt();
		trap(SUPERVISOR, SUPERVISOR_SOFTWARE_INTERRUPT, rv32x.epc, 0x00000000);
	}
	func supervisor_timer_interrupt {
		interrupt();
		trap(SUPERVISOR, SUPERVISOR_TIMER_INTERRUPT, rv32x.epc, 0x00000000);
	}
	func load_store_amo_address_breakpoint_exception {
		exception();
	}
	func store_amo_address_misaligned_exception {
		exception();
		rv32x.get_inst_execute();
		rv32x.get_pc_execute();
		trap(MACHINE, STORE_AMO_ADDRESS_MISALIGNED, rv32x.epc, rv32x.misaligned_memory_address);
		rv32x.stall_ifetch_req();
		rv32x.stall_decode_req();
		rv32x.stall_execute_req();
		rv32x.flush_ifetch();
		rv32x.flush_decode();
		rv32x.flush_execute();
#ifdef DEBUG
		debug_einst := rv32x.einst;
#endif
	}
	func load_address_misaligned_exception {
		exception();
		rv32x.get_inst_execute();
		rv32x.get_pc_execute();
		trap(MACHINE, LOAD_ADDRESS_MISALIGNED, rv32x.epc, rv32x.misaligned_memory_address);
		rv32x.stall_ifetch_req();
		rv32x.stall_decode_req();
		rv32x.stall_execute_req();
		rv32x.flush_ifetch();
		rv32x.flush_decode();
		rv32x.flush_execute();
#ifdef DEBUG
		debug_einst := rv32x.einst;
#endif
	}
	func store_amo_page_fault_exception {
		exception();
	}
	func load_page_fault_exception {
		exception();
	}
	func store_amo_access_fault_exception {
		exception();
	}
	func load_access_fault_exception {
		exception();
	}
	func illegal_instruction_exception {
		exception();
		rv32x.get_pc_execute();
		rv32x.get_inst_execute();
		trap(MACHINE, ILLEGAL_INSTRUCTION, rv32x.epc, rv32x.einst);
		rv32x.stall_ifetch_req();
		rv32x.stall_decode_req();
		rv32x.stall_execute_req();
		rv32x.flush_ifetch();
		rv32x.flush_decode();
		rv32x.flush_execute();
#ifdef DEBUG
		debug_einst := rv32x.einst;
#endif
	}
	func environment_call_exception {
		exception();
		rv32x.get_pc_execute();
		rv32x.get_inst_execute();

		any {
			(mode == MACHINE): {
				trap(MACHINE, ENVIRONMENT_CALL_FROM_M_MODE, rv32x.epc, 0x00000000);
			}
			(mode == SUPERVISOR) && (~medeleg.environment_call_from_s_mode): {
				trap(MACHINE, ENVIRONMENT_CALL_FROM_S_MODE, rv32x.epc, 0x00000000);
			}
			(mode == SUPERVISOR) && (medeleg.environment_call_from_s_mode): {
				trap(SUPERVISOR, ENVIRONMENT_CALL_FROM_S_MODE, rv32x.epc, 0x00000000);
			}
			(mode == USER) && (~medeleg.environment_call_from_u_mode): {
				trap(MACHINE, ENVIRONMENT_CALL_FROM_U_MODE, rv32x.epc, 0x00000000);
			}
			(mode == USER) && (~medeleg.environment_call_from_u_mode): {
				trap(SUPERVISOR, ENVIRONMENT_CALL_FROM_U_MODE, rv32x.epc, 0x00000000);
			}
		}
		rv32x.stall_ifetch_req();
		rv32x.stall_decode_req();
		rv32x.stall_execute_req();
		rv32x.flush_ifetch();
		rv32x.flush_decode();
		rv32x.flush_execute();
#ifdef DEBUG
		debug_einst := rv32x.einst;
#endif
	}
	func environment_break_exception {
		exception();
		rv32x.get_pc_execute();
		rv32x.get_inst_execute();
		trap(MACHINE, BREAKPOINT, rv32x.epc, rv32x.epc);
		rv32x.stall_ifetch_req();
		rv32x.stall_decode_req();
		rv32x.stall_execute_req();
		rv32x.flush_ifetch();
		rv32x.flush_decode();
		rv32x.flush_execute();
#ifdef DEBUG
		debug_einst := rv32x.einst;
#endif
	}
	func instruction_address_misaligned_exception {
		exception();
		rv32x.get_pc_execute();	
		trap(MACHINE, INSTRUCTION_ADDRESS_MISALIGNED, rv32x.epc, rv32x.misaligned_target_address);
		rv32x.stall_ifetch_req();
		rv32x.flush_ifetch();
		rv32x.stall_decode_req();
		rv32x.flush_decode();
		rv32x.stall_execute_req();
		rv32x.flush_execute();
#ifdef DEBUG
		rv32x.get_inst_execute();
		debug_einst := rv32x.einst;
#endif
	}
	func instruction_address_breakpoint_exception {
		exception();
	}
	func instruction_page_fault_exception {
		exception();
	}
	func instruction_access_fault_exception {
		exception();
	}
	func rv32x.mret {
		if(mode != MACHINE) {
			illegal_instruction();
		} else {
			mtval := 0;
			trap_mret();
			rv32x.stall_ifetch_req();
			rv32x.stall_decode_req();
			rv32x.flush_ifetch();
			rv32x.flush_decode();
		}
	}
	func rv32x.sret {
		if((mode != SUPERVISOR) || mstatus.tsr) {
			illegal_instruction();
		} else {
			stval := 0;
			trap_sret();
			rv32x.stall_ifetch_req();
			rv32x.stall_decode_req();
			rv32x.flush_ifetch();
			rv32x.flush_decode();
		}
	}
	func rv32x.uret {
		if(mode != USER) {
			illegal_instruction();
		} else {
			utval := 0;
			trap_uret();
			rv32x.stall_ifetch_req();
			rv32x.stall_decode_req();
			rv32x.flush_ifetch();
			rv32x.flush_decode();
		}
	}
	proc trap_mret {
		mstatus.mie 	:= mstatus.mpie;
		mstatus.mpie	:= 1;
		mstatus.mpp		:= MACHINE;
		mstatus.mprv 	:= 0;
		mode 			:= mstatus.mpp;
		rv32x.stall_ifetch_req();
		rv32x.trap({mepc[31:2], mepc[1:0] & ~ialign});
		finish();
	}
	proc trap_sret {
		mstatus.sie		:= sstatus.spie;
		sstatus.sie		:= sstatus.spie;
		mstatus.spie	:= 1;
		sstatus.spie	:= 1;
		mstatus.mprv 	:= if(mode == MACHINE) 1'b0 else mstatus.mprv;
		mode 			:= sstatus.spp;	
		rv32x.stall_ifetch_req();
		rv32x.trap({sepc[31:2], sepc[1:0] & ~ialign});
		finish();
	}
	proc trap_uret {
		mstatus.uie		:= ustatus.upie;
		sstatus.uie		:= ustatus.upie;
		ustatus.uie		:= ustatus.upie;
		mstatus.upie	:= 1;
		sstatus.upie	:= 1;
		ustatus.upie	:= 1;
		mode			:= USER;
		rv32x.stall_ifetch_req();
		rv32x.trap({uepc[31:2], uepc[1:0] & ~ialign});
		finish();
	}
	proc trap {
		wire v[32];
		mtvec_t wire tvec;
		
		any {
			trap_mode == MACHINE: {
				mode			:= MACHINE;
				mstatus.mpie 	:= mstatus.mie;
				mstatus.mie 	:= 0;
				mstatus.mpp 	:= mode;
				mcause 			:= cause;
				mepc 			:= epc;
				mtval			:= tval;
				tvec 			= mtvec;
			}
			trap_mode == SUPERVISOR: {
				mode			:= SUPERVISOR;
				mstatus.spp		:= mode;
				sstatus.spp		:= mode;
				mstatus.spie 	:= sstatus.sie;
				sstatus.spie 	:= sstatus.sie;
				mstatus.sie		:= 0;
				sstatus.sie		:= 0;
				scause			:= cause;
				sepc			:= epc;
				stval			:= tval;
				tvec			= stvec;
			}
			trap_mode == USER: {
				mode			:= USER;
				mstatus.upie 	:= ustatus.uie;
				sstatus.upie 	:= ustatus.uie;
				ustatus.upie 	:= ustatus.uie;
				mstatus.uie		:= 0;
				sstatus.uie		:= 0;
				ustatus.uie		:= 0;
				ucause			:= cause;
				mepc			:= epc;
				utval			:= tval;
				tvec			= utvec;
			}
		}

		any {
			tvec.mode == 2'b00: 				v = {tvec.base, 2'b00};
			tvec.mode == 2'b01 && !cause[31]:	v = {tvec.base, 2'b00};
			tvec.mode == 2'b01 && cause[31]:	v = {tvec.base, 2'b00}
														+32'({cause[9:0], 2'b00});
		}
		rv32x.stall_ifetch_req();
		rv32x.trap(v);
#ifdef DEBUG
		debug_raise_exception(cause, epc, mtval, debug_einst);
#endif
		finish();
	}
	/* fence.i */
	func rv32x.fencei {
		if(!ic_invalidate_done) {
			ic.invalidate();
		}
		if(!dc_flush_done) {
			dc.flush();
		}
		if(dc_flush_done && ic_invalidate_done) {
			ic_invalidate_done := 0;
			dc_flush_done := 0;
			rv32x.dmem_valid();
		}
	}
	func rv32x.fence {
		rv32x.dmem_valid();
	}
	func ic.invalidate_done {
		ic_invalidate_done := 1;
	}
	func dc.flush_done {
		dc_flush_done := 1;
	}
	func ic.mem_read {
		reg ic_read_cnt[3] = 0;
		mem ic_read_data[4][32];
		
		imem_read({ic.mem_adrs[31:4], 4'({ic_read_cnt, 2'b00})}, MEM_WORD);
		if(ic_read_cnt == 4) {
			if(imem_valid) {
				ic_read_cnt := 0;
				ic.mem_rdata = {ic_read_data[3], ic_read_data[2], ic_read_data[1], ic_read_data[0]};
				ic.mem_valid();
			}
		} else {
			if(imem_valid) {
				ic_read_cnt++;
				ic_read_data[ic_read_cnt] := inst;
			}
		}
	}
	func rv32x.imem_read {
		ic.read(rv32x.iaddr);
	}
	func ic.valid {
		rv32x.inst = ic.rdata;
		rv32x.imem_valid();
	}
	func rv32x.dmem_read {

		check_daddr_range(rv32x.daddr);
		any {
			cacheable && !not_mapped:					dc.read(rv32x.daddr, rv32x.dbyteen);
			!cacheable && !not_mapped:					noncacheable_read(rv32x.daddr, rv32x.dbyteen);	
			not_mapped:									load_access_fault(); 
		}
	}
	func noncacheable_read {
		dmem_read(ncadrs, ncbyteen);
		if(dmem_valid) {
			rv32x.rdata = rdata;
			rv32x.dmem_valid();
		}
	}
	func dc.mem_read {
		reg dc_read_cnt[3] = 0;
		mem dc_read_data[4][32];

		dmem_read({dc.mem_adrs[31:4], 4'({dc_read_cnt, 2'b00})}, MEM_WORD);
		if(dc_read_cnt == 4) {
			if(dmem_valid) {
				dc_read_cnt := 0;
				dc.mem_rdata = {dc_read_data[3], dc_read_data[2], dc_read_data[1], dc_read_data[0]};
				dc.mem_valid();
			}
		} else {
			if(dmem_valid) {
				dc_read_cnt++;
				dc_read_data[dc_read_cnt] := rdata;
			}
		}
	}
	func rv32x.dmem_write {
		check_daddr_range(rv32x.daddr);
		any {
			cacheable && !not_mapped:					dc.write(rv32x.daddr, rv32x.dbyteen, rv32x.wdata);
			!cacheable && !not_mapped:					noncacheable_write(rv32x.daddr, rv32x.dbyteen, rv32x.wdata);
			not_mapped:									store_amo_access_fault();
		}
#ifdef DEBUG
		if(rv32x.daddr == 0x80001000) {
			sim_done(rv32x.wdata);
		}
#endif
	}
	func noncacheable_write {
		dmem_write(ncadrs, ncbyteen, ncdata);
		if(dmem_valid) {
			rv32x.dmem_valid();
		}
	}
	func dc.mem_write {
		reg dc_write_cnt[3] = 0;
		mem dc_write_data[4][32];
		
		dmem_write({dc.mem_adrs[31:4], 4'({dc_write_cnt, 2'b00})}, MEM_WORD, dc_write_data[dc_write_cnt]);
		any {
			dc_write_cnt == 0: {
				dc_write_data[0] := dc.mem_wdata[31:0];
				dc_write_data[1] := dc.mem_wdata[63:32];
				dc_write_data[2] := dc.mem_wdata[95:64];
				dc_write_data[3] := dc.mem_wdata[127:96];
				dc_write_cnt++;
			}
			dc_write_cnt == 4: {
				if(dmem_valid) {
					dc_write_cnt := 0;
					dc.mem_valid();
				}
			}
			else: {
				if(dmem_valid) {
					dc_write_cnt++;
				}
			}
		}
	}
	func dc.valid {
		rv32x.rdata = dc.rdata;
		rv32x.dmem_valid();
	}
#ifdef DEBUG
	debug_x0  = rv32x.debug_x0;
	debug_x1  = rv32x.debug_x1;
	debug_x2  = rv32x.debug_x2;
	debug_x3  = rv32x.debug_x3;
	debug_x4  = rv32x.debug_x4;
	debug_x5  = rv32x.debug_x5;
	debug_x6  = rv32x.debug_x6;
	debug_x7  = rv32x.debug_x7;
	debug_x8  = rv32x.debug_x8;
	debug_x9  = rv32x.debug_x9;
	debug_x10 = rv32x.debug_x10;
	debug_x11 = rv32x.debug_x11;
	debug_x12 = rv32x.debug_x12;
	debug_x13 = rv32x.debug_x13;
	debug_x14 = rv32x.debug_x14;
	debug_x15 = rv32x.debug_x15;
	debug_x16 = rv32x.debug_x16;
	debug_x17 = rv32x.debug_x17;
	debug_x18 = rv32x.debug_x18;
	debug_x19 = rv32x.debug_x19;
	debug_x20 = rv32x.debug_x20;
	debug_x21 = rv32x.debug_x21;
	debug_x22 = rv32x.debug_x22;
	debug_x23 = rv32x.debug_x23;
	debug_x24 = rv32x.debug_x24;
	debug_x25 = rv32x.debug_x25;
	debug_x26 = rv32x.debug_x26;
	debug_x27 = rv32x.debug_x27;
	debug_x28 = rv32x.debug_x28;
	debug_x29 = rv32x.debug_x29;
	debug_x30 = rv32x.debug_x30;
	debug_x31 = rv32x.debug_x31;
	debug_pc = rv32x.debug_pc;
	func rv32x.debug_retire {
		debug_retire(rv32x.debug_retire_pc, rv32x.debug_retire_inst);
	}
	func rv32x.debug_wb {
		debug_wb(rv32x.debug_wb_rd, rv32x.debug_wb_data);
	}
	func rv32x.debug_mem_write {
		debug_mem_write(rv32x.debug_mem_adrs, rv32x.debug_mem_byteen, rv32x.debug_mem_data);
	}
#endif
}
