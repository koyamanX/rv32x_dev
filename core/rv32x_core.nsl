#include "rv32x_core.h"
#include "rv32x5p.h"
#include "opcode.h"
#include "priv.h"
#include "csr.h"
#include "ifetch_unit.h"
#include "load_store_unit.h"

module rv32x_core {
	rv32x5p rv32x;							/* 5-stage pipelined processor(single issue, in-order) */
	ifetch_unit ic;
	load_store_unit lsu;
	csr32 csr;
	reg ic_invalidate_done = 0;
	reg ic_tlb_flush_done = 0;
	reg lsu_cache_flush_done = 0;
	reg lsu_tlb_flush_done = 0;
	wire in_memory_operation;
	reg priv_mode[2];						/* Current priv mode */
	reg valid_pipeline;
	func_self invalidate_pipeline();
	
	reg ic_read_cnt[3] = 0;
	reg ic_prefetch_cnt[3] = 0;
	reg lsu_read_cnt[3] = 0;
	reg lsu_prefetch_cnt[3] = 0;

	reg exception_val[32] = 0;

	/* Trap */
	reg trap_cause[32];
	reg trap_pc[32];
	reg trap_val[32];
	reg trap_priv_mode[2];
	proc_name trap(trap_priv_mode, trap_cause, trap_pc, trap_val);
	/* Interrupts */
	func_self interrupt();
	func_self machine_interrupt_enabled();
	func_self supervisor_interrupt_enabled();
	/* Pending interrupts */
	func_self machine_timer_interrupt_pending();
	func_self machine_software_interrupt_pending();
	func_self machine_external_interrupt_pending();
	func_self supervisor_timer_interrupt_pending();
	func_self supervisor_software_interrupt_pending();
	func_self supervisor_external_interrupt_pending();
	/* Exceptions */
	func_self exception();
	func_self instruction_address_breakpoint_exception();
	func_self instruction_page_fault_exception();
	func_self instruction_access_fault_exception();
	func_self illegal_instruction_execute_stage_exception();
	func_self illegal_instruction_memory_stage_exception();
	func_self instruction_address_misaligned_exception();
	func_self environment_call_exception();
	func_self environment_break_exception();
	func_self load_store_amo_address_breakpoint_exception();
	func_self store_amo_address_misaligned_exception();
	func_self load_address_misaligned_exception();
	func_self store_amo_page_fault_exception();
	func_self load_page_fault_exception();
	func_self store_amo_access_fault_exception();
	func_self load_access_fault_exception();
	/* Pending exceptions */
	func_self instruction_address_breakpoint();
	func_self instruction_page_fault();
	func_self instruction_access_fault();
	func_self illegal_instruction_execute_stage();
	func_self illegal_instruction_memory_stage();
	func_self instruction_address_misaligned();
	func_self environment_call();
	func_self environment_break();
	func_self load_store_amo_address_breakpoint();
	func_self store_amo_address_misaligned();
	func_self load_address_misaligned();
	func_self store_amo_page_fault();
	func_self load_page_fault();
	func_self store_amo_access_fault();
	func_self load_access_fault();
	func_self machine_timer_interrupt();
	func_self machine_external_interrupt();
	func_self machine_software_interrupt();
	func_self supervisor_timer_interrupt();
	func_self supervisor_external_interrupt();
	func_self supervisor_software_interrupt();
	/* Interrupts sources */
	wire msip;
	wire mtip;
	wire meip;
	wire ssip;
	wire stip;
	wire seip;

	wire sxlen[2];
	wire uxlen[2];
	wire ialign[2];
	wire retaddr[32];

	mip_t wire mip;
	mie_t wire mie;
	sie_t wire sie;
	satp_t wire satp;
	mstatus_t wire mstatus;
	sstatus_t wire sstatus;
	mideleg_t wire mideleg;
	medeleg_t wire medeleg;

    mip = csr.mip_;
	mie = csr.mie_;
	sie = csr.sie_;
    satp = csr.satp_;
    mstatus = csr.mstatus_;
    sstatus = csr.sstatus_;
    mideleg = csr.mideleg_;
    medeleg = csr.medeleg_;
	csr.priv_mode = priv_mode;
	csr.instret = rv32x.instret;
	csr.meip = meip;
	csr.mtip = mtip;
	csr.msip = msip;
	csr.seip = seip;
	csr.stip = stip;
	csr.ssip = ssip;
	csr.ialign = ialign;
	
	sxlen = MISA_MXL_32;
	uxlen = MISA_MXL_32;
	ialign = 2'b01;

	/* checking !trap is required, since most of interrupt pending bits
		only be cleared from software via writing one of correspoinding
		register in PLIC, CLINT not xip registers(some may be read-only).
		Hence, until disabling xstatus.mie, interrupts pendings are handled
		many times. So check if currently handling interrupts(in trap state)
		or not.
	*/
	in_memory_operation = rv32x.fencei || rv32x.sfence_vma || rv32x.dmem_read || rv32x.dmem_write || rv32x.load_reserved || rv32x.store_conditional || rv32x.amo_exe;
	if(((priv_mode < MACHINE) || ((priv_mode == MACHINE) && mstatus.mie)) && !trap && !in_memory_operation && valid_pipeline && !rv32x.trap_mret) {
		machine_interrupt_enabled();
	}
	if(((priv_mode < SUPERVISOR) || ((priv_mode == SUPERVISOR) && mstatus.sie)) && !trap && !in_memory_operation && valid_pipeline && !rv32x.trap_sret) {
		supervisor_interrupt_enabled();
	}
	if(meip && mie.meie) {
		machine_external_interrupt_pending();
	}
	if(mtip && mie.mtie) {
		machine_timer_interrupt_pending();
	}
	if(msip && mie.msie) {
		machine_software_interrupt_pending();
	}
	if(seip && sie.seie) {
		supervisor_external_interrupt_pending();
	}
	if(stip && sie.stie) {
		supervisor_timer_interrupt_pending();
	}
	if(ssip && sie.ssie) {
		supervisor_software_interrupt_pending();
	}

	msip = (machine_software_interrupt_req);
	mtip = (machine_timer_interrupt_req);
	meip = (machine_external_interrupt_req);
	ssip = ((supervisor_software_interrupt_req | mip.ssip));
	stip = ((supervisor_timer_interrupt_req | mip.stip));
	seip = ((supervisor_external_interrupt_req | mip.seip));

	lsu.satp_mode	= satp.mode;
	lsu.satp_asid	= satp.asid;
	lsu.satp_ppn	= satp.ppn;
	lsu.mstatus_mxr	= mstatus.mxr;
	lsu.sstatus_sum	= sstatus.sum;
	lsu.priv_mode	= if(mstatus.mprv) mstatus.mpp else priv_mode;

	ic.priv_mode	= priv_mode;
	ic.satp_mode = satp.mode;
	ic.satp_ppn = satp.ppn;

	rv32x.ialign = ialign;

	func reset {
		wire resetvector[32];

		priv_mode 					:= MACHINE;
		csr.reset();
		ic.reset();
		lsu.reset();
		resetvector = {0x00000000};	/* Shynchronous execption(RESET) */
		rv32x.reset(resetvector);
	}
	/* CSR accesses */
	func rv32x.csr_read {
		if(csr.read_not_mapped) {
			illegal_instruction_memory_stage();
		}
		return csr.read(rv32x.cradrs);
	}
	func rv32x.csr_write {
		csr.write(rv32x.cwadrs, rv32x.cwdata);
		if(csr.write_not_mapped) {
			illegal_instruction_memory_stage();
		}
	}
	func rv32x.ecall {
		environment_call();
	}
	func rv32x.wfi {
		any {
			/* no bounded time limit, so always generates illegal instruction exception on less priv */
			(mstatus.tw && priv_mode == USER):			illegal_instruction_execute_stage();
			(mstatus.tw && priv_mode == SUPERVISOR):	illegal_instruction_execute_stage();
		}
	}
	func rv32x.ebreak {
		environment_break();
	}
	func rv32x.illegal_instruction_execute_stage {
		illegal_instruction_execute_stage();
	}
	func rv32x.instruction_address_misaligned {
		instruction_address_misaligned();
	}
	func rv32x.store_address_misaligned {
		store_amo_address_misaligned();
	}
	func rv32x.load_address_misaligned {
		load_address_misaligned();
	}
	/* Trap priority encoder */
	alt {
		/* Interrupt has higher priorities than exceptions */
		machine_interrupt_enabled && machine_external_interrupt_pending:		machine_external_interrupt();
		machine_interrupt_enabled && machine_software_interrupt_pending:		machine_software_interrupt();
		machine_interrupt_enabled && machine_timer_interrupt_pending:			machine_timer_interrupt();
		machine_interrupt_enabled
					&& supervisor_external_interrupt_pending && ~mideleg.seip:	supervisor_external_interrupt();
		machine_interrupt_enabled
					&& supervisor_software_interrupt_pending && ~mideleg.ssip:	supervisor_software_interrupt();
		machine_interrupt_enabled
					&& supervisor_timer_interrupt_pending && ~mideleg.stip:		supervisor_timer_interrupt();
		supervisor_interrupt_enabled
					&& supervisor_external_interrupt_pending && mideleg.seip:	supervisor_external_interrupt();
		supervisor_interrupt_enabled
					&& supervisor_software_interrupt_pending && mideleg.ssip:	supervisor_software_interrupt();
		supervisor_interrupt_enabled
					&& supervisor_timer_interrupt_pending && mideleg.stip:		supervisor_timer_interrupt();
		/* Process exception in preceeding instruction in pipeline */	
		rv32x.exception_req:	exception();
	}
	func rv32x.validate_pipeline{
		valid_pipeline := 1;
	}
	func invalidate_pipeline{
		valid_pipeline := 0;
	}
	func interrupt {
		rv32x.stall_ifetch_req();
		rv32x.stall_decode_req();
		rv32x.stall_execute_req();
		rv32x.stall_memory_req();
		rv32x.flush_ifetch();
		rv32x.flush_decode();
		rv32x.flush_execute();
		rv32x.flush_memory();
		rv32x.get_pc_trap();
		invalidate_pipeline();
	}
	func exception{
		wire delegation;
		rv32x.get_pc_trap();
		invalidate_pipeline();
		any{
			rv32x.exception_cause == STORE_AMO_PAGE_FAULT: delegation = medeleg.store_amo_page_fault;
			rv32x.exception_cause == LOAD_PAGE_FAULT: delegation = medeleg.load_page_fault;
			rv32x.exception_cause == INSTRUCTION_PAGE_FAULT: delegation = medeleg.instruction_page_fault;
			rv32x.exception_cause == ENVIRONMENT_CALL_FROM_M_MODE: delegation = medeleg.environment_call_from_m_mode;
			rv32x.exception_cause == ENVIRONMENT_CALL_FROM_S_MODE: delegation = medeleg.environment_call_from_s_mode;
			rv32x.exception_cause == ENVIRONMENT_CALL_FROM_U_MODE: delegation = medeleg.environment_call_from_u_mode;
			rv32x.exception_cause == STORE_AMO_ACCESS_FAULT: delegation = medeleg.store_amo_access_fault;
			rv32x.exception_cause == STORE_AMO_ADDRESS_MISALIGNED: delegation = medeleg.store_amo_address_misaligned;
			rv32x.exception_cause == LOAD_ACCESS_FAULT: delegation = medeleg.load_access_fault;
			rv32x.exception_cause == LOAD_ADDRESS_MISALIGNED: delegation = medeleg.load_address_misaligned;
			rv32x.exception_cause == BREAKPOINT: delegation = medeleg.breakpoint;
			rv32x.exception_cause == ILLEGAL_INSTRUCTION: delegation = medeleg.illegal_instruction;
			rv32x.exception_cause == INSTRUCTION_ACCESS_FAULT: delegation = medeleg.instruction_access_fault;
			rv32x.exception_cause == INSTRUCTION_ADDRESS_MISALIGNED: delegation = medeleg.instruction_address_misaligned;
		}
		any {
			priv_mode <= SUPERVISOR && delegation:	trap(SUPERVISOR, rv32x.exception_cause, rv32x.epc, exception_val);
			else:	trap(MACHINE, rv32x.exception_cause, rv32x.epc, exception_val);
		}
	}
	func machine_external_interrupt {
		interrupt();
		trap(MACHINE, MACHINE_EXTERNAL_INTERRUPT, rv32x.epc, 0x00000000);
	}
	func machine_software_interrupt {
		interrupt();
		trap(MACHINE, MACHINE_SOFTWARE_INTERRUPT, rv32x.epc, 0x00000000);
	}
	func machine_timer_interrupt {
		interrupt();
		trap(MACHINE, MACHINE_TIMER_INTERRUPT, rv32x.epc, 0x00000000);
	}
	func supervisor_external_interrupt {
		interrupt();
		any {
			~mideleg.seip: trap(MACHINE, SUPERVISOR_EXTERNAL_INTERRUPT, rv32x.epc, 0x00000000);
			mideleg.seip: trap(SUPERVISOR, SUPERVISOR_EXTERNAL_INTERRUPT, rv32x.epc, 0x00000000);
		}
	}
	func supervisor_software_interrupt {
		interrupt();
		any {
			~mideleg.ssip: trap(MACHINE, SUPERVISOR_SOFTWARE_INTERRUPT, rv32x.epc, 0x00000000);
			mideleg.ssip: trap(SUPERVISOR, SUPERVISOR_SOFTWARE_INTERRUPT, rv32x.epc, 0x00000000);
		}
	}
	func supervisor_timer_interrupt {
		interrupt();
		any {
			~mideleg.stip: trap(MACHINE, SUPERVISOR_TIMER_INTERRUPT, rv32x.epc, 0x00000000);
			mideleg.stip: trap(SUPERVISOR, SUPERVISOR_TIMER_INTERRUPT, rv32x.epc, 0x00000000);
		}
	}
	func illegal_instruction_memory_stage{
		rv32x.memory_exception = {1'b1,ILLEGAL_INSTRUCTION};
		rv32x.get_inst_memory();
		exception_val := rv32x.einst;
		rv32x.stall_ifetch_req();
		rv32x.stall_decode_req();
		rv32x.stall_execute_req();
		rv32x.flush_ifetch();
		rv32x.flush_decode();
		rv32x.flush_execute();
	}
	func store_amo_page_fault{
		rv32x.memory_exception = {1'b1,STORE_AMO_PAGE_FAULT};
		exception_val := rv32x.daddr;
		rv32x.stall_ifetch_req();
		rv32x.stall_decode_req();
		rv32x.stall_execute_req();
		rv32x.flush_ifetch();
		rv32x.flush_decode();
		rv32x.flush_execute();
	}
	func load_page_fault{
		rv32x.memory_exception = {1'b1,LOAD_PAGE_FAULT};
		exception_val := rv32x.daddr;
		rv32x.stall_ifetch_req();
		rv32x.stall_decode_req();
		rv32x.stall_execute_req();
		rv32x.flush_ifetch();
		rv32x.flush_decode();
		rv32x.flush_execute();
	}
	func store_amo_access_fault{
		rv32x.memory_exception = {1'b1,STORE_AMO_ACCESS_FAULT};
		exception_val := rv32x.daddr;
		rv32x.stall_ifetch_req();
		rv32x.stall_decode_req();
		rv32x.stall_execute_req();
		rv32x.flush_ifetch();
		rv32x.flush_decode();
		rv32x.flush_execute();
	}
	func load_access_fault{
		rv32x.memory_exception = {1'b1,LOAD_ACCESS_FAULT};
		exception_val := rv32x.daddr;
		rv32x.stall_ifetch_req();
		rv32x.stall_decode_req();
		rv32x.stall_execute_req();
		rv32x.flush_ifetch();
		rv32x.flush_decode();
		rv32x.flush_execute();
	}
	func illegal_instruction_execute_stage{
		rv32x.execute_exception = {1'b1,ILLEGAL_INSTRUCTION};
		rv32x.get_inst_execute();
		exception_val := rv32x.einst;
		rv32x.stall_ifetch_req();
		rv32x.stall_decode_req();
		rv32x.flush_ifetch();
		rv32x.flush_decode();
	}
	func instruction_address_misaligned{
		rv32x.execute_exception = {1'b1,INSTRUCTION_ADDRESS_MISALIGNED};
		exception_val := rv32x.misaligned_target_address;
		rv32x.stall_ifetch_req();
		rv32x.stall_decode_req();
		rv32x.flush_ifetch();
		rv32x.flush_decode();
	}
	func store_amo_address_misaligned{
		rv32x.execute_exception = {1'b1,STORE_AMO_ADDRESS_MISALIGNED};
		exception_val := rv32x.misaligned_memory_address;
		rv32x.stall_ifetch_req();
		rv32x.stall_decode_req();
		rv32x.flush_ifetch();
		rv32x.flush_decode();
	}
	func load_address_misaligned{
		rv32x.execute_exception = {1'b1,LOAD_ADDRESS_MISALIGNED};
		exception_val := rv32x.misaligned_memory_address;
		rv32x.stall_ifetch_req();
		rv32x.stall_decode_req();
		rv32x.flush_ifetch();
		rv32x.flush_decode();
	}
	func environment_call{
		any {
			(priv_mode == MACHINE): {
				rv32x.execute_exception = {1'b1,ENVIRONMENT_CALL_FROM_M_MODE};
			}
			(priv_mode == SUPERVISOR): {
				rv32x.execute_exception = {1'b1,ENVIRONMENT_CALL_FROM_S_MODE};
			}
			(priv_mode == USER): {
				rv32x.execute_exception = {1'b1,ENVIRONMENT_CALL_FROM_U_MODE};
			}
		}
		exception_val := 0x00000000;
		rv32x.stall_ifetch_req();
		rv32x.stall_decode_req();
		rv32x.flush_ifetch();
		rv32x.flush_decode();
	}
	func environment_break{
		rv32x.execute_exception = {1'b1,BREAKPOINT};
		exception_val := rv32x.epc;
		rv32x.stall_ifetch_req();
		rv32x.stall_decode_req();
		rv32x.flush_ifetch();
		rv32x.flush_decode();
	}
	func instruction_page_fault{
		rv32x.ifetch_exception = {1'b1,INSTRUCTION_PAGE_FAULT};
		exception_val := rv32x.iaddr;
	}
	func instruction_access_fault{
		rv32x.ifetch_exception = {1'b1,INSTRUCTION_ACCESS_FAULT};
		exception_val := rv32x.iaddr;
	}
	func rv32x.mret {
		if(priv_mode != MACHINE) {
			illegal_instruction_execute_stage();
		} else {
			rv32x.stall_ifetch_req();
			rv32x.stall_decode_req();
			rv32x.flush_ifetch();
			rv32x.flush_decode();
		}
	}
	func rv32x.sret {
		if((priv_mode == SUPERVISOR) && mstatus.tsr) {
			illegal_instruction_execute_stage();
		} else {
			rv32x.stall_ifetch_req();
			rv32x.stall_decode_req();
			rv32x.flush_ifetch();
			rv32x.flush_decode();
		}
	}
	func rv32x.trap_mret {
		retaddr = csr.trap_ret(MACHINE);
		priv_mode 		:= mstatus.mpp;
		rv32x.trap({retaddr[31:2], retaddr[1:0] & ~ialign});
		invalidate_pipeline();
	}
	func rv32x.trap_sret {
		retaddr = csr.trap_ret(SUPERVISOR);
		priv_mode 		:= {1'b0, sstatus.spp};	
		rv32x.trap({retaddr[31:2], retaddr[1:0] & ~ialign});
		invalidate_pipeline();
	}
	proc trap {
		wire v[32];
		mtvec_t wire tvec;
		priv_mode		:= trap_priv_mode;
		tvec = csr.trap(trap_priv_mode, trap_cause, trap_pc, trap_val);
		any {
			tvec.mode == 2'b00: 					v = {tvec.base, 2'b00};
			tvec.mode == 2'b01 && !trap_cause[31]:	v = {tvec.base, 2'b00};
			tvec.mode == 2'b01 && trap_cause[31]:	v = ({tvec.base, 2'b00} + 32'({trap_cause[9:0], 2'b00}));
		}
		rv32x.stall_ifetch_req();
		rv32x.trap(v);
		finish();
	}
	/* fence.i */
	func rv32x.fencei {
		if(!ic_invalidate_done) {
			ic.invalidate();
		}
		if(!lsu_cache_flush_done) {
			lsu.cache_flush();
		}
		if(lsu_cache_flush_done && ic_invalidate_done) {
			ic_invalidate_done := 0;
			lsu_cache_flush_done := 0;
			rv32x.dmem_ready();
		}
	}
	func rv32x.fence {
		rv32x.dmem_ready();
	}
	func rv32x.sfence_vma {
		if(((priv_mode == SUPERVISOR) && mstatus.tvm)) {
			illegal_instruction_memory_stage();
		} else {
			if(ic_tlb_flush_done && ic_invalidate_done && lsu_tlb_flush_done) {
				ic_tlb_flush_done := 0;
				ic_invalidate_done := 0;
				lsu_tlb_flush_done := 0;
				rv32x.dmem_ready();
			}
			if(!ic_tlb_flush_done) {
				ic.tlb_flush();
			}
			if(!ic_invalidate_done) {
				ic.invalidate();
			}
			if(!lsu_tlb_flush_done) {
				lsu.tlb_flush();
			}
		}
	}
	func ic.instruction_page_fault if(ic.vaddr == rv32x.iaddr){	//check the fault address is not invalid address(the instruction when branch prediction failed and flushed )
		instruction_page_fault();
	}
	func ic.instruction_access_fault if(ic.vaddr == rv32x.iaddr){	//same above
		instruction_access_fault();
	}
	func ic.tlb_flush_done {
		ic_tlb_flush_done		:= 1;
	}
	func ic.invalidate_done {
		ic_invalidate_done 		:= 1;
	}
	func lsu.cache_flush_done {
		lsu_cache_flush_done	:= 1;
	}
	func lsu.tlb_flush_done {
		lsu_tlb_flush_done		:= 1;
	}
	func ic.mem_read {
		#define PREFETCH_BYTES 4
		mem ic_read_data[4][32];
		if(ic_prefetch_cnt < PREFETCH_BYTES){
			imem_read({ic.mem_addr[31:4], 4'({ic_prefetch_cnt, 2'b00})}, MEM_WORD);
			ic_prefetch_cnt++;
		}
		if(ic_read_cnt == 4) {
				ic_read_cnt := 0;
				ic_prefetch_cnt := 0;
				ic.mem_rdata = {ic_read_data[3], ic_read_data[2], ic_read_data[1], ic_read_data[0]};
				ic.mem_ready();
		}
		if(imem_ready) {
			ic_read_cnt++;
			ic_read_data[ic_read_cnt] := inst;
		}
	}
	func ic.walk {
		lsu.read_tlb(ic.vaddr);
	}
	func lsu.pte_ready {
		ic.pte = lsu.pte;
		ic.pte_levels = lsu.pte_levels;
		ic.pte_ready();
	}
	func lsu.tlb_page_fault {
		ic.walk_page_fault();
	}
	func lsu.tlb_access_fault {
		ic.walk_access_fault();
	}
	func rv32x.imem_read {
		ic.read(rv32x.iaddr);
	}
	func ic.ready {
		rv32x.insts = ic.insts;
		rv32x.imem_ready();
	}
	func rv32x.dmem_read {
		lsu.load(rv32x.daddr, rv32x.dbyteen);
	}
	func rv32x.load_reserved {
		lsu.load_reserved();
	}
	func rv32x.amo_exe {
		lsu.amo_exe(rv32x.amo_src, rv32x.amo_addr, rv32x.amo_funct5, rv32x.amo_aq, rv32x.amo_rl, rv32x.amo_width);
	}
	func lsu.store_amo_access_fault {
		store_amo_access_fault();
	}
	func lsu.load_access_fault {
		load_access_fault();
	}
	func lsu.load_page_fault {
		load_page_fault();
	}
	func lsu.store_amo_page_fault {
		store_amo_page_fault();
	}

	/* PMAs */
	func ic.pma_check {
		imem_pma_check(ic.pma_addr);
	}
	func imem_pma_executable {
		ic.pma_executable();
	}
	func imem_pma_readable {
		ic.pma_readable();
	}
	func imem_pma_word {
		ic.pma_word();
	}
	func imem_pma_halfword {
		ic.pma_halfword();
	}
	func imem_pma_cacheable {
		ic.pma_cacheable();
	}
	func imem_pma_empty {
		ic.pma_empty();
	}
	func lsu.pma_check {
		dmem_pma_check(lsu.pma_addr);
	}
	func dmem_pma_writable {
		lsu.pma_writable();
	}
	func dmem_pma_readable {
		lsu.pma_readable();
	}
	func dmem_pma_atomic {
		lsu.pma_atomic();
	}
	func dmem_pma_word {
		lsu.pma_word();
	}
	func dmem_pma_halfword {
		lsu.pma_halfword();
	}
	func dmem_pma_byte {
		lsu.pma_byte();
	}
	func dmem_pma_cacheable {
		lsu.pma_cacheable();
	}
	func dmem_pma_empty {
		lsu.pma_empty();
	}

	func lsu.dbus_read {
		mem lsu_read_data[4][32];

		if(lsu.dbus_size == MEM_QUADWORD) { //ram read
			if(lsu_prefetch_cnt < PREFETCH_BYTES){
				dmem_read({lsu.dbus_addr[31:4], 4'({lsu_prefetch_cnt, 2'b00})}, MEM_WORD);
				lsu_prefetch_cnt++;
			}
			if(lsu_read_cnt == 4) {
					lsu_read_cnt := 0;
					lsu_prefetch_cnt := 0;
					lsu.dbus_rdata = {lsu_read_data[3], lsu_read_data[2], lsu_read_data[1], lsu_read_data[0]};
					lsu.dbus_ready();
			}
			if(dmem_ready) {
				lsu_read_cnt++;
				lsu_read_data[lsu_read_cnt] := rdata;
			}
		} else {	//memory mapped i/o read
			dmem_read(lsu.dbus_addr, lsu.dbus_size);
			if(dmem_ready) {
				lsu.dbus_rdata = 128'(rdata);
				lsu.dbus_ready();
			}
		}
	}
	func rv32x.dmem_write {
		lsu.store(rv32x.daddr, rv32x.dbyteen, rv32x.wdata);
	}
	func rv32x.store_conditional {
		lsu.store_conditional();
	}
	func lsu.dbus_write {
		reg lsu_write_cnt[3] = 0;
		
		if(lsu.dbus_size == MEM_QUADWORD) {	//writeback cache
			any {
				lsu_write_cnt == 0: dmem_write({lsu.dbus_addr[31:4], 4'({lsu_write_cnt, 2'b00})}, MEM_WORD, lsu.dbus_wdata[31:0]);
				lsu_write_cnt == 1: dmem_write({lsu.dbus_addr[31:4], 4'({lsu_write_cnt, 2'b00})}, MEM_WORD, lsu.dbus_wdata[63:32]);
				lsu_write_cnt == 2: dmem_write({lsu.dbus_addr[31:4], 4'({lsu_write_cnt, 2'b00})}, MEM_WORD, lsu.dbus_wdata[95:64]);
				lsu_write_cnt == 3: dmem_write({lsu.dbus_addr[31:4], 4'({lsu_write_cnt, 2'b00})}, MEM_WORD, lsu.dbus_wdata[127:96]);
				(lsu_write_cnt == 4 && dmem_ready): {
					lsu_write_cnt := 0;
					lsu.dbus_ready();
				}
				lsu_write_cnt < 4: lsu_write_cnt++;
			}
		} else {	//memory mapped i/o write
			dmem_write(lsu.dbus_addr, lsu.dbus_size, lsu.dbus_wdata[31:0]);
			if(dmem_ready) {
				lsu.dbus_ready();
			}
		}
	}
	func lsu.ready {
		rv32x.rdata = lsu.load_data;
		rv32x.dmem_ready();
	}
#ifdef SIM
	func lsu.sim_done {
		sim_done(lsu.tohost);
	}
#endif
#ifdef CV
	rv32x.SW = SW;
	func rv32x.debug_led_1{
		debug_led_1();
	}	
	func rv32x.debug_led_2{
		debug_led_2();
	}	
	func rv32x.debug_led_3{
		debug_led_3();
	}	
	func rv32x.debug_led_4{
		debug_led_4();
	}	
	func rv32x.debug_led_5{
		debug_led_5();
	}
	func rv32x.debug_led_6{
		debug_led_6();
	}
	func rv32x.debug_led_7{
		debug_led_7();
	}
	func rv32x.debug_led_8{
		debug_led_8();
	}
	func rv32x.debug_pc_led{
		debug_pc_led(rv32x.pc_led);
	}
	func rv32x.debug_sseg_l16{
		debug_sseg_l16(rv32x.sseg_l16);
	}
	func rv32x.debug_sseg_l12{
		debug_sseg_l12(rv32x.sseg_l12);
	}
	func rv32x.debug_sseg_h12{
		debug_sseg_h12(rv32x.sseg_h12);
	}
	func ic.debug_led_1{
		debug_led_1();
	}	
	func ic.debug_led_2{
		debug_led_2();
	}	
	func ic.debug_led_3{
		debug_led_3();
	}	
	func ic.debug_led_4{
		debug_led_4();
	}	
	func ic.debug_led_5{
		debug_led_5();
	}
	func ic.debug_led_6{
		debug_led_6();
	}
	func ic.debug_led_7{
		debug_led_7();
	}
	func ic.debug_led_8{
		debug_led_8();
	}
#endif
}
