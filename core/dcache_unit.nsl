#include "dcache_unit.h"
#define MEM_WORD        3'b010
#define MEM_HALFWORD    3'b001
#define MEM_BYTE        3'b000

module dcache_unit {
	wire tag[20];
	wire index[8];
	wire blockoffset[2];
	wire byteoffset[2];
	wire cache_block[128];
	wire cache_word[32];
	wire byteen_mask[32];
	wire wb_data[128];
	wire wb_mask[128];
	wire flush_index[8];
	reg reg_adrs[32];
	reg reg_byteen[3];
	reg reg_data[32];
	reg flush_cnt[9] = 0;
	reg cdata[128];
	reg cvalid;
	reg cdirty;
	reg ctag[20];
	wire t[20], i[8], l[2], y[2];
	mem cache_data[256][128];
	mem cache_valid[256] = {0};
	mem cache_tag[256][20];
	mem cache_dirty[256] = {0};

	func_self hit();
	func_self miss();
	func_self refill();
	func_self dirty();
	func_self clean();
	proc_name idle();
	/* registering output of mem block is required to infer bram */
	proc_name compare_tag(reg_adrs, reg_byteen, reg_data, cdata, ctag, cvalid, cdirty);
	proc_name writeback(reg_adrs, reg_byteen, reg_data);
	proc_name allocate(reg_adrs, reg_byteen, reg_data); 
	proc_name flush_cache();

	.{tag, index, blockoffset, byteoffset} = reg_adrs;
	.{t, i, l, y} = adrs;

	func reset {
		idle();
	}

	proc idle {
		if(flush) {
			flush_cache();
		} else if(read || write) {
			compare_tag(adrs, byteen, wdata, cache_data[i], cache_tag[i], cache_valid[i], cache_dirty[i]);
		}
	}
	proc compare_tag {
		/* checking (index == i) is required, to support cancellation of read operation in any stage */
		if(cvalid && (ctag == tag) && (index == i)) {
			hit();
		} else {
			miss();
		}
		if(cdirty == DIRTY) {
			dirty();
		} else {
			clean();
		}
		if(hit) {
			idle();
		} else if(miss && clean) {
			allocate(reg_adrs, reg_byteen, reg_data);
		} else if(miss && dirty) {
			writeback(reg_adrs, reg_byteen, reg_data);
		}
	}
	func hit {
		cache_block = cdata;
		any {
			reg_byteen == MEM_WORD: {byteen_mask = 0xffff_ffff; wb_data = 4{reg_data};}
			reg_byteen == MEM_HALFWORD: {byteen_mask = 0x0000_ffff; wb_data = 8{reg_data[15:0]};}
			reg_byteen == MEM_BYTE: {byteen_mask = 0x0000_00ff; wb_data = 16{reg_data[7:0]};}
		}
		any {
			read: {
				any {
					blockoffset == 2'b00: cache_word = cache_block[31:0];
					blockoffset == 2'b01: cache_word = cache_block[63:32];
					blockoffset == 2'b10: cache_word = cache_block[95:64];
					blockoffset == 2'b11: cache_word = cache_block[127:96];
				}
				rdata = (cache_word >> 5'({byteoffset, 3'b000})) & byteen_mask;
				valid();
			}
			write: {
				any {
					blockoffset == 2'b00: {
						wb_mask = {0x0000_0000, 0x0000_0000, 0x0000_0000, 32'((byteen_mask << 5'({byteoffset, 3'b000}))[31:0])};
					}
					blockoffset == 2'b01: {
						wb_mask = {0x0000_0000, 0x0000_0000, 32'((byteen_mask << 5'({byteoffset, 3'b000}))[31:0]), 0x0000_0000};
					}
					blockoffset == 2'b10: {
						wb_mask = {0x0000_0000, 32'((byteen_mask << 5'({byteoffset, 3'b000}))[31:0]), 0x0000_0000, 0x0000_0000};
					}
					blockoffset == 2'b11: {
						wb_mask = {32'((byteen_mask << 5'({byteoffset, 3'b000}))[31:0]), 0x0000_0000, 0x0000_0000, 0x0000_0000};
					}
				}

				cache_data[index] := (cache_block & ~wb_mask) | (wb_data & wb_mask);
				cache_tag[index] := tag;
				cache_valid[index] := VALID;
				cache_dirty[index] := DIRTY;
				valid();
			}
		}
	}
	proc writeback {
		mem_write({tag, index, 4'b0000}, cdata);
		cache_valid[index] := INVALID;
		cache_dirty[index] := CLEAN;
		if(mem_valid) {
			allocate(reg_adrs, reg_byteen, reg_data);
		}
	}
	proc allocate {
		mem_read({tag, index, 4'b0000});
		if(mem_valid) {
			refill();
			compare_tag(adrs, byteen, wdata, cache_data[i], cache_tag[i], cache_valid[i], cache_dirty[i]);
		}
	}
	func refill {
		cache_data[index] := mem_rdata;
		cache_tag[index] := tag;
		cache_valid[index] := VALID;
		cache_dirty[index] := CLEAN;
	}
	proc flush_cache {
		flush_index = flush_cnt[7:0];
		if(flush_cnt == 256) {
			flush_cnt := 0;
			flush_done();
			idle();
		} else {
			if(cache_dirty[flush_index] == DIRTY) {
				mem_write({cache_tag[flush_index], flush_index, 4'b0000}, cache_data[flush_index]);
				if(mem_valid) {
					cache_valid[flush_index] := INVALID;
					cache_dirty[flush_index] := CLEAN;
					flush_cnt++;
				}
			} else {
				flush_cnt++;
			}
		}
	}
}
