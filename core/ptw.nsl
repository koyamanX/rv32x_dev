#include "ptw.h"
#include "csr.h"
#include "opcode.h"

module ptw {
	proc_name idle();
	reg levels[2];
	reg pa_pt_adrs[34];
	reg va_vpn0[10];
	reg page_table_entry[32];
	proc_name page_table_walk(levels, pa_pt_adrs, va_vpn0);
	proc_name pte_check(levels, va_vpn0, page_table_entry);

	func reset {
		idle();
	}
	proc idle {
		wire satp_mode;
		wire satp_asid[9];
		wire satp_ppn[22];
		sv32_va_t wire sv32_va;

		sv32_va = vadrs;
		.{satp_mode, satp_asid, satp_ppn} = satp;
		if(walk) {
			page_table_walk(LEVELS-1, ({satp_ppn, 0x000} + sv32_va.vpn1), sv32_va.vpn0);
		}
	}
	proc page_table_walk {
		mem_read(pa_pt_adrs);
		if(mem_valid) {
			pte_check(levels, va_vpn0, mem_rdata);
		}
	}
	proc pte_check {
		sv32_pte_t wire sv32_pte;
		
		sv32_pte = page_table_entry;

		any {
			((levels == 0) && !(sv32_pte.x || sv32_pte.w || sv32_pte.r)): {
				page_fault();
				idle();
			}
			((levels == 0) || (sv32_pte.x || sv32_pte.w || sv32_pte.r)): {
				pte_valid(page_table_entry);
				idle();
			}
			else: {
				page_table_walk(levels-1, ({sv32_pte.ppn1, sv32_pte.ppn0, 0x000} + va_vpn0), 10'(0x0));
			}
		}
	}
}


declare translate_test {
	param_int TEST_ID = 0;
	func_out success();
	func_out fail();
}
module translate_test {
	reg r = 0;
	func_self tst;
	ptw walker;
	satp_t wire satp;
	sv32_va_t wire va;
	sv32_pte_t wire pte0;
	sv32_pte_t wire pte1;
	func_self nop;
	reg i[5];

	if(~r) {
		r := ~r;
		tst();
	}
	
	/* satp points to PA(0x8200_0000) */
	satp.mode = 1;
	satp.asid = 0;
	satp.ppn = {2'b00, 0x82000};
	walker.satp = satp;

	/* VA(0x00402000) maps to PA(0x8300_0000) */
	va.vpn1 = 10'(0x1);
	va.vpn0 = 10'(0x2);
	va.page_offset = 12'(0x0);

	func tst seq {
		walker.reset();
		walker.walk(va);	// idle
		walker.walk(va);	// page_table_walk, level==1
		walker.walk(va);	// pte_check, level==1
		walker.walk(va);	// page_table_walk, level==0
		walker.walk(va);	// pte_check, level==0

		for(i := 0; i < 32; i++) {
			nop();
		}
		_write("fail(TEST_ID %x): timeout\n", TEST_ID);
		fail();
	}

	/* pte_t *pte1 = 0x8200_0001; */
	pte1.ppn1 = 12'b00_1000_0010_00;
	pte1.ppn0 = 10'b01_0000_0000;
	pte1.rsw = 0;
	pte1.d = 0;
	pte1.a = 0;
	pte1.g = 0;
	pte1.u = 0;
	pte1.x = 0;
	pte1.w = 0;
	pte1.r = 0;
	pte1.v = 1;

	/* pte_t *pte0 = 0x8210_0002; */
	pte0.ppn1 = 12'b00_1000_0011_00;
	pte0.ppn0 = 10'b00_0000_0000;
	pte0.rsw = 0;
	pte0.d = 0;
	pte0.a = 0;
	pte0.g = 0;
	pte0.u = 0;
	pte0.x = 1;
	pte0.w = 1;
	pte0.r = 1;
	pte0.v = 1;

	func walker.mem_read {
		any {
			walker.mem_adrs == {2'b00, 0x82000001}: walker.mem_rdata = pte1;
			walker.mem_adrs == {2'b00, 0x82100002}: walker.mem_rdata = pte0;
			else: { _write("fail(TEST_ID %x): invalid memory address\n", TEST_ID); fail(); }
		}
		walker.mem_valid();
	}
	func walker.page_fault {
		_write("fail(TEST_ID %x): page_fault\n", TEST_ID);
		fail();
	}
	func walker.pte_valid {
		sv32_pte_t wire pte;

		pte = walker.pte;
		any {
			(pte0 == pte): { _write("success(TEST_ID %x): PTE: %x, PA: %x\n", TEST_ID, pte, {pte.ppn1, pte.ppn0, va.page_offset}); success(); }
			(pte0 != pte): { _write("fail(TEST_ID %x): PTE: %x but should be %x\n", TEST_ID, pte, pte1); fail(); }
		}
	}
}

declare test simulation {}
module test {
	translate_test test0(TEST_ID=0);

	any {
		test0.success:	_finish("all test passed");
		test0.fail: 	_finish("test0 failed");
	}
}
