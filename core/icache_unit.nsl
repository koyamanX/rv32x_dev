#include "icache_unit.h"
#include "csr.h"
#define MEM_WORD        3'b010
#define MEM_HALFWORD    3'b001
#define MEM_BYTE        3'b000

module icache_unit {
	proc_name idle();
	/* registering output of mem block is required to infer bram */
	reg cache_data_entry[128];
	reg cache_tag_entry[20];
	reg cache_valid_entry;
	reg cache_tag_accessing[20];	/* physical tag, if no paging, then virtual tag == physical tag */
	reg cache_index_accessing[8];
	proc_name compare_tag(cache_data_entry, cache_tag_entry, cache_valid_entry, cache_tag_accessing, cache_index_accessing);
	reg allocate_adrs[32];
	proc_name allocate(allocate_adrs); 
	reg ptw_vadrs[32];	/* virtual address used for page_table_walk */
	proc_name page_table_walk(ptw_vadrs);
	proc_name flush_tlb();
	proc_name invalidate_cache();

	mem cache_data[256][128];
	mem cache_valid[256] = {0};
	mem cache_tag[256][20] = {0};

	func_self cache_hit();
	func_self cache_miss();
	wire refill_tag[20];
	wire refill_index[8];
	func_self refill(refill_tag, refill_index);

	mem tlb_data[4][32];
	mem tlb_valid[4] = {0};
	mem tlb_tag[4][20] = {0};
	reg tlb_random_replace_pos[2] = 0;

	wire va[32];
	func_self access_tlb(va);
	wire tlb_hit_data[32];
	func_self tlb_hit(tlb_hit_data);
	func_self tlb_miss();

	wire tag[20];
	wire index[8];
	wire blockoffset[2];
	wire byteoffset[2];

	integer i_;	/* only used by `generate` construct and re-used in this module */

	.{tag, index, blockoffset, byteoffset} = adrs;
	tlb_random_replace_pos++;

	func reset {
		idle();
	}
	proc idle {
		sv32_pte_t wire sv32_pte;

		if(invalidate) {
			invalidate_cache();
		} else if(tlb_flush) {
			flush_tlb();
		} else if(read && satp_mode) {
			access_tlb(adrs);
			if(tlb_hit) {
				sv32_pte = tlb_hit_data;
				if(sv32_pte.x && !sv32_pte.u) {
					/* map 32 bits virtual address to 32 bits physical address on sv32, not 34 bit physical address for now */
					compare_tag(cache_data[index], cache_tag[index], cache_valid[index], ({sv32_pte.ppn1, sv32_pte.ppn0})[19:0], index);
				} else {
					instruction_page_fault();
				}
			} else if(tlb_miss) {
				page_table_walk(adrs);
			}
		} else if(read && !satp_mode) {
			compare_tag(cache_data[index], cache_tag[index], cache_valid[index], tag, index);
		}
	}
	proc flush_tlb {
		generate(i_ = 0; i_ < 4; i_++) {
			tlb_valid[i_] := INVALID;
		}
		tlb_flush_done();
		idle();
	}
	func access_tlb {
		generate(i_ = 0; i_ < 4; i_++) {
			if(tlb_valid[i_] && (tlb_tag[i_] == va[31:12])) {
				tlb_hit(tlb_data[i_]);
			}
		}
		if(!tlb_hit) {
			tlb_miss();
		}
	}
	proc page_table_walk {
		walk({satp_mode, satp_asid, satp_ppn}, ptw_vadrs);
		if(pte_valid) {
			tlb_data[tlb_random_replace_pos] := pte;
			tlb_tag[tlb_random_replace_pos] := ptw_vadrs[31:12];
			tlb_valid[tlb_random_replace_pos] := VALID;
			idle();
		} else if(page_fault) {
			instruction_page_fault();
			idle();
		}
	}
	proc compare_tag {
		/* checking (cache_index_accessing == index) is required, to support cancellation of read operation in this stage 
			if not above equation holds, then read is cancelled implicitly by changing `adrs` during `read` (in the case of
			branch, jump and trap), so restart from idle();
		*/
		if(cache_valid_entry && (cache_tag_entry == cache_tag_accessing) && (cache_index_accessing == index)) {
			cache_hit();
			idle();
		} else if(cache_index_accessing != index) {
			idle();
		} else {
			cache_miss();
			/* use physical tag and page_offset(untranslated part of adrs(lower 12 bits))
				to form address for allocate cache block 
				again, if sv32 is not enabled, physical tag maps to virtual tag */
			allocate({cache_tag_accessing, adrs[11:0]});
		}
	}
	func cache_hit {
		wire cache_block[128];
		wire cache_word[32];

		cache_block = cache_data_entry;
		any {
			blockoffset == 2'b00: cache_word = cache_block[31:0];
			blockoffset == 2'b01: cache_word = cache_block[63:32];
			blockoffset == 2'b10: cache_word = cache_block[95:64];
			blockoffset == 2'b11: cache_word = cache_block[127:96];
		}
		if(read) {
			rdata = cache_word;
			valid();
		}
	}
	proc allocate {
		wire allocate_tag[20];
		wire allocate_index[8];
		wire allocate_blockoffset[2];
		wire allocate_byteoffset[2];
		.{allocate_tag, allocate_index, allocate_blockoffset, allocate_byteoffset} = allocate_adrs;

		/* mem_read with physical address */
		mem_read({allocate_tag, allocate_index, 4'b0000});
		if(mem_valid) {
			refill(allocate_tag, allocate_index);
			idle();
		}
	}
	func refill {
		cache_data[refill_index] := mem_rdata;
		cache_tag[refill_index] := refill_tag;
		cache_valid[refill_index] := VALID;
	}
	proc invalidate_cache seq {
		reg invalidate_cnt[9] = 0;
		wire invalidate_index[8];

		/* no dirty cache entry, just invaldate all entry */
		for(invalidate_cnt := 0; invalidate_cnt < 256; invalidate_cnt++) {
			invalidate_index = invalidate_cnt[7:0];
			cache_valid[invalidate_index] := INVALID;
		}
		{
			invalidate_done();
			idle();
		}
	}
}

#ifdef UNIT_TEST
declare icache_va_read_test {
	param_int TEST_ID = 0;
	func_out success();
	func_out fail();
}
#include "ptw.nsl"
module icache_va_read_test {
	reg r = 0;
	func_self tst;
	ptw walker;
	icache_unit ic;
	satp_t wire satp;
	sv32_va_t wire va;
	sv32_pte_t wire pte0;
	sv32_pte_t wire pte1;
	func_self nop;
	reg i[5];

	if(~r) {
		r := ~r;
		tst();
	}
	
	/* satp points to PA(0x8200_0000) */
	satp.mode = 1;
	satp.asid = 0;
	satp.ppn = {2'b00, 0x82000};

	/* VA(0x00402000) maps to PA(0x8300_0000) */
	va.vpn1 = 10'(0x1);
	va.vpn0 = 10'(0x2);
	va.page_offset = 12'(0x0);

	ic.satp_mode = satp.mode;
	ic.satp_asid = satp.asid;
	ic.satp_ppn = satp.ppn;

	func tst seq {
		{
			walker.reset();
			ic.reset();
		}
		ic.read(0x00402000);	// idle
		ic.read(0x00402000);	// tlb_miss && page_table_walk();
		nop();					// page_table_walk  (idle)
		nop();					// page_table_walk	(page_table_walk)
		nop();					// page_table_walk	(pte_check)
		nop();					// page_table_walk	(page_table_walk)
		nop();					// page_table_walk	(pte_check)
		ic.read(0x00402000);	// idle
		ic.read(0x00402000);	// tlb_hit && compare_tag();
		ic.read(0x00402000);	// allocate
		ic.read(0x00402000);	// idle
		ic.read(0x00402000);	// compare_tag() tlb_hit && cache_hit


		for(i := 0; i < 32; i++) {
			nop();
		}
		_write("fail(TEST_ID %x): timeout\n", TEST_ID);
		fail();
	}
	func ic.walk {
		walker.walk(ic.satp, ic.vadrs);	
	}
	func walker.pte_valid {
		ic.pte = walker.pte;
		ic.pte_valid();
	}
	func walker.page_fault {
		ic.page_fault();
	}
	/* VA(0x00402000) maps to PA(0x8300_0000) */
	func ic.mem_read {
		any {
			ic.mem_adrs == 0x8300_0000: { ic.mem_rdata = 0x0123_4567_89ab_cdef_fedc_ba98_7654_3210; ic.mem_valid(); }
			else:	{ _write("fail(TEST_ID %x): miss translation\n", TEST_ID); fail(); }
		}
	}
	func ic.valid {
		_write("success(TEST_ID %x): data: %x\n", TEST_ID, ic.rdata);
		success();
	}

	/* pte_t *pte1 = 0x8200_0001; */
	pte1.ppn1 = 12'b00_1000_0010_00;
	pte1.ppn0 = 10'b01_0000_0000;
	pte1.rsw = 0;
	pte1.d = 0;
	pte1.a = 0;
	pte1.g = 0;
	pte1.u = 0;
	pte1.x = 0;
	pte1.w = 0;
	pte1.r = 0;
	pte1.v = 1;

	/* pte_t *pte0 = 0x8210_0002; */
	pte0.ppn1 = 12'b00_1000_0011_00;
	pte0.ppn0 = 10'b00_0000_0000;
	pte0.rsw = 0;
	pte0.d = 0;
	pte0.a = 0;
	pte0.g = 0;
	pte0.u = 0;
	pte0.x = 1;
	pte0.w = 1;
	pte0.r = 1;
	pte0.v = 1;

	func walker.mem_read {
		any {
			walker.mem_adrs == {2'b00, 0x82000004}: walker.mem_rdata = pte1;
			walker.mem_adrs == {2'b00, 0x82100008}: walker.mem_rdata = pte0;
			else: { _write("fail(TEST_ID %x): invalid memory address\n", TEST_ID); fail(); }
		}
		walker.mem_valid();
	}
}

declare icache_test simulation {}
module icache_test {
	icache_va_read_test test0(TEST_ID=0);

	any {
		test0.success:	_finish("all test passed");
		test0.fail: 	_finish("test0 failed");
	}
}
#endif
