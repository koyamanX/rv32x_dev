#include "icache_unit.h"
#define MEM_WORD        3'b010
#define MEM_HALFWORD    3'b001
#define MEM_BYTE        3'b000

module icache_unit {
	wire tag[20];
	wire index[8];
	wire blockoffset[2];
	wire byteoffset[2];
	wire cache_block[128];
	wire cache_word[32];
	wire invalidate_index[8];
	reg reg_adrs[32];
	reg invalidate_cnt[9] = 0;
	reg cdata[128];
	reg cvalid;
	reg ctag[20];
	wire t[20], i[8], l[2], y[2];
	mem cache_data[256][128];
	mem cache_valid[256] = {0};
	mem cache_tag[256][20];

	func_self hit();
	func_self miss();
	func_self refill();
	proc_name idle();
	/* registering output of mem block is required to infer bram */
	proc_name compare_tag(reg_adrs, cdata, ctag, cvalid);
	proc_name allocate(reg_adrs); 
	proc_name invalidate_cache();

	.{tag, index, blockoffset, byteoffset} = reg_adrs;
	.{t, i, l, y} = adrs;


	func reset {
		idle();
	}
	proc idle {
		if(invalidate) {
			invalidate_cache();
		} else if(read) {
			compare_tag(adrs, cache_data[i], cache_tag[i], cache_valid[i]);
		}
	}
	proc compare_tag {
		/* checking (index == i) is required, to support cancellation of read operation in any stage */
		if(cvalid && (ctag == tag) && (index == i)) {
			hit();
		} else {
			miss();
		}
		if(hit) {
			idle();
		} else if(miss) {
			allocate(reg_adrs);
		}
	}
	func hit {
		cache_block = cdata;
		any {
			blockoffset == 2'b00: cache_word = cache_block[31:0];
			blockoffset == 2'b01: cache_word = cache_block[63:32];
			blockoffset == 2'b10: cache_word = cache_block[95:64];
			blockoffset == 2'b11: cache_word = cache_block[127:96];
		}
		if(read) {
			rdata = (cache_word >> 5'({byteoffset, 3'b000})) & 0xffff_ffff;
			valid();
		}
	}
	proc allocate {
		mem_read({tag, index, 4'b0000});
		if(mem_valid) {
			refill();
			/* use new address to enable cancellation of read operation */
			compare_tag(adrs, cache_data[i], cache_tag[i], cache_valid[i]);
		}
	}
	func refill {
		cache_data[index] := mem_rdata;
		cache_tag[index] := tag;
		cache_valid[index] := VALID;
	}
	proc invalidate_cache {
		invalidate_index = invalidate_cnt[7:0];
		if(invalidate_cnt == 256) {
			invalidate_cnt := 0;
			invalidate_done();
			idle();
		} else {
			cache_valid[invalidate_index] := INVALID;
			invalidate_cnt++;
		}
	}
}
