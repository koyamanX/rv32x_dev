#include "icache_unit.h"
#define MEM_WORD        3'b010
#define MEM_HALFWORD    3'b001
#define MEM_BYTE        3'b000

module icache_unit {
	wire tag[20];
	wire index[8];
	wire blockoffset[2];
	wire byteoffset[2];
	wire cache_block[128];
	wire cache_word[32];
	wire invalidate_index[8];
	reg allocate_adrs[32];
	reg invalidate_cnt[9] = 0;
	reg cache_data_entry[128];
	reg cache_valid_entry;
	reg cache_tag_entry[20];
	reg cache_index_accessing[8];
	reg cache_tag_accessing[20];
	mem cache_data[256][128];
	mem cache_valid[256] = {0};
	mem cache_tag[256][20];

	func_self cache_hit();
	func_self cache_miss();
	wire refill_tag[20];
	wire refill_index[8];
	func_self refill(refill_tag, refill_index);
	proc_name idle();
	/* registering output of mem block is required to infer bram */
	proc_name compare_tag(cache_data_entry, cache_tag_entry, cache_valid_entry, cache_tag_accessing, cache_index_accessing);
	proc_name allocate(allocate_adrs); 
	proc_name invalidate_cache();

	.{tag, index, blockoffset, byteoffset} = adrs;


	func reset {
		idle();
	}
	proc idle {
		if(invalidate) {
			invalidate_cache();
		} else if(read) {
			compare_tag(cache_data[index], cache_tag[index], cache_valid[index], tag, index);
		}
	}
	proc compare_tag {
		/* checking (index == i) is required, to support cancellation of read operation in this stage */
		if(cache_valid_entry && (cache_tag_entry == cache_tag_accessing) && (cache_index_accessing == index)) {
			cache_hit();
			idle();
		} else {
			cache_miss();
			allocate(adrs);
		}
	}
	func cache_hit {
		cache_block = cache_data_entry;
		any {
			blockoffset == 2'b00: cache_word = cache_block[31:0];
			blockoffset == 2'b01: cache_word = cache_block[63:32];
			blockoffset == 2'b10: cache_word = cache_block[95:64];
			blockoffset == 2'b11: cache_word = cache_block[127:96];
		}
		if(read) {
			rdata = cache_word;
			valid();
		}
	}
	proc allocate {
		wire allocate_tag[20];
		wire allocate_index[8];
		wire allocate_blockoffset[2];
		wire allocate_byteoffset[2];
		.{allocate_tag, allocate_index, allocate_blockoffset, allocate_byteoffset} = allocate_adrs;

		mem_read({allocate_tag, allocate_index, 4'b0000});
		if(mem_valid) {
			refill(allocate_tag, allocate_index);
			/* use new address to enable cancellation of read operation */
			compare_tag(cache_data[index], cache_tag[index], cache_valid[index], tag, index);
		}
	}
	func refill {
		cache_data[refill_index] := mem_rdata;
		cache_tag[refill_index] := refill_tag;
		cache_valid[refill_index] := VALID;
	}
	proc invalidate_cache seq {
		for(invalidate_cnt := 0; invalidate_cnt < 256; invalidate_cnt++) {
			invalidate_index = invalidate_cnt[7:0];
			cache_valid[invalidate_index] := INVALID;
		}
		{
			invalidate_done();
			idle();
		}
	}
}
