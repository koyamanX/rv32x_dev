#include "load_store_unit.h"
#include "cache.h"
#include "opcode.h"
#include "csr.h"
#include "ptw.h"

#define MEM_WORD        3'b010
#define MEM_HALFWORD    3'b001
#define MEM_BYTE        3'b000

#define PTW_FETCH		2'b00
#define PTW_LOAD		2'b10
#define PTW_STORE		2'b11

#define CACHE_LOAD		2'b00
#define CACHE_STORE		2'b01

module load_store_unit {
	reg cache_adrs[32];
	reg cache_wdata[32];
	reg cache_byteen[3];
	reg ptw_op[2];
	reg ptw_adrs[32];
	reg cache_sc;

	proc_name idle();
	proc_name flush_cache();
	proc_name read_cache(cache_adrs, cache_byteen);
	proc_name write_cache(cache_adrs, cache_byteen, cache_wdata, cache_sc);
	proc_name flush_tlb();
	proc_name page_table_walk(ptw_op, ptw_adrs);
	cache dcache;
	ptw walker;

	mem tlb_data[32][32];
	mem tlb_levels[32][2];
	mem tlb_valid[32] = {0};
	mem tlb_tag[32][20] = {0};
	reg tlb_random_replace_pos[5] = 0;

	wire va_tag[20];
	func_self access_tlb(va_tag);
	wire tlb_hit_data[32];
	wire tlb_hit_levels[2];
	func_self tlb_hit(tlb_hit_data, tlb_hit_levels);
	func_self tlb_miss();

	wire refill_tlb_tag[20];
	wire refill_tlb_data[32];
	wire refill_tlb_levels[2];
	func_self refill_tlb(refill_tlb_tag, refill_tlb_data, refill_tlb_levels);

	wire translate_cache_access_type[2];
	wire translate_valid;
	wire va[32];
	wire pa[32];							/* valid on translate_valid */
	func_self translate(translate_cache_access_type, va) : translate_valid;
	reservation_t reg reservation = 0;

	wire sv32;

	integer i_;

	tlb_random_replace_pos++;
	sv32 = (satp_mode && (priv_mode != MACHINE));

	func reset {
		reservation.valid := 0;
		dcache.reset();
		walker.reset();
		idle();
	}
	proc idle {
		wire sv32_va[32];
		wire sv32_pa[32];

		sv32_va = adrs;
		sv32_pa = pa;
		alt {
			cache_flush: {
				dcache.cache_flush();
				flush_cache();		
			}
			tlb_flush: {
				flush_tlb();
			}
			load: {
				if(translate(CACHE_LOAD, sv32_va)) {
					read_cache(sv32_pa, byteen);
					if(load_reserved) {
						reservation.valid := 1;
						reservation.addr := sv32_pa;
					}
				} else {
					page_table_walk(PTW_LOAD, sv32_va);
				}
			}
			store: {
				if(translate(CACHE_STORE, sv32_va)) {
					if(store_conditional && (!(reservation.valid && (reservation.addr == sv32_pa)))) {
						store_conditional_status = 1;
						valid();
					} else {
						write_cache(sv32_pa, byteen, store_data, store_conditional);
					}
					if(store_conditional) {
						reservation.valid := 0;
					}
				} else {
					page_table_walk(PTW_STORE, sv32_va);
				}
#ifdef DEBUG
				if(sv32_pa == 0x80001000) {
					sim_done(store_data);
				}
#endif
			}
			read_utlb: {
				access_tlb(utlb_adrs[31:12]);

				if(tlb_hit) {
					utlb_pte = tlb_hit_data;
					utlb_pte_levels = tlb_hit_levels;
					utlb_pte_valid();
				}
				if(tlb_miss) {
					page_table_walk(PTW_FETCH, utlb_adrs);
				}
			}
		}
	}
	func translate {
		sv32_pte_t wire sv32_pte;

		if(sv32) {
			access_tlb(va[31:12]);
			sv32_pte = tlb_hit_data;	/* valid on (tlb_hit) */
			any {
				(translate_cache_access_type == CACHE_LOAD) && tlb_hit: {
					if(sv32_pte.v && (sv32_pte.r || (mstatus_mxr && sv32_pte.x)) && sv32_pte.a
						&& ((sv32_pte.u && ((priv_mode == USER) || ((priv_mode == SUPERVISOR) && sstatus_sum))) || (!sv32_pte.u && priv_mode != USER))) {
							return 1;
					} else {
						load_page_fault();
						return 0;
					}
				}
				(translate_cache_access_type == CACHE_STORE) && tlb_hit: {
					if(sv32_pte.v && sv32_pte.r && sv32_pte.w && sv32_pte.a && sv32_pte.d
						&& ((sv32_pte.u && ((priv_mode == USER) || ((priv_mode == SUPERVISOR) && sstatus_sum))) || (!sv32_pte.u && priv_mode != USER))) {
							return 1;
					} else {
						store_amo_page_fault();
						return 0;
					}
				}
				else: {
					return 0;
				}
			}
			any {
				tlb_hit_levels == 0:	pa = {sv32_pte.ppn1[9:0], sv32_pte.ppn0, va[11:0]};
				tlb_hit_levels == 1:	pa = {sv32_pte.ppn1[9:0], va[21:0]};
			}
		} else {
			pa = va;
			return 1;
		}
	}
	proc flush_cache {
		dcache.cache_flush();

		if(dcache.cache_flush_done) {
			cache_flush_done();
			idle();
		}
	}
	proc flush_tlb {
		generate(i_ = 0; i_ < 32; i_++) {
			tlb_valid[i_] := INVALID;
		}
		tlb_flush_done();
		idle();
	}
	proc read_cache {
		dcache.read(cache_adrs, cache_byteen);	

		if(dcache.valid) {
			load_data = dcache.rdata;
			valid();
			idle();
		}
		if(dcache.load_access_fault) {
			idle();
		}
	}
	proc write_cache {
		dcache.write(cache_adrs, cache_byteen, cache_wdata);	

		if(dcache.valid) {
			store_conditional_status = ~cache_sc;
			valid();
			idle();
		}
		if(dcache.store_amo_access_fault) {
			store_conditional_status = 1'b1;
			idle();
		}
	}
	proc page_table_walk {
		walker.walk({satp_mode, satp_asid, satp_ppn}, ptw_adrs);

		if(walker.pte_valid) {
			refill_tlb(ptw_adrs[31:12], walker.pte, walker.pte_levels);
			idle();
		}
		if(walker.page_fault) {
			idle();
		}
		if(dcache.load_access_fault) {
			idle();
		}
	}
	func walker.mem_read {
		dcache.read(walker.mem_adrs[31:0], MEM_WORD);	

		if(dcache.valid) {
			walker.mem_rdata = dcache.rdata[31:0];
			walker.mem_valid();
		}
	}
	func access_tlb {
		generate(i_ = 0; i_ < 32; i_++) {
			if(tlb_valid[i_] && (tlb_tag[i_] == va_tag)) {
				tlb_hit(tlb_data[i_], tlb_levels[i_]);
			}
		}
		if(!tlb_hit) {
			tlb_miss();
		}
	}
	func refill_tlb {
		tlb_data[tlb_random_replace_pos] := refill_tlb_data;
		tlb_tag[tlb_random_replace_pos] := refill_tlb_tag;
		tlb_levels[tlb_random_replace_pos] := refill_tlb_levels;
		tlb_valid[tlb_random_replace_pos] := VALID;
	}
	func dcache.pma_check {
		pma_check(dcache.pma_adrs);
	}
	func pma_empty {
		dcache.pma_empty();
	}
	func pma_cacheable {
		dcache.pma_cacheable();
	}
	func dcache.mem_read {
		mem_read(dcache.mem_adrs, dcache.mem_size);
	}
	func dcache.mem_write {
		mem_write(dcache.mem_adrs, dcache.mem_size, dcache.mem_wdata);
	}
	func mem_valid {
		dcache.mem_rdata = mem_rdata;
		dcache.mem_valid();
	}
	func dcache.store_amo_access_fault {
		store_amo_access_fault();
	}
	func dcache.load_access_fault {
		any {
			page_table_walk && ptw_op == PTW_FETCH: utlb_access_fault();
			else: 									load_access_fault();
		}
	}
	func walker.page_fault {
		any {
			ptw_op == PTW_FETCH:	utlb_page_fault();
			ptw_op == PTW_STORE:	store_amo_page_fault();
			ptw_op == PTW_LOAD:		load_page_fault();
		}
	}
}
