#include "load_store_unit.h"
#include "cache.h"
#include "opcode.h"
#include "csr.h"
#include "ptw.h"

#define MEM_WORD        3'b010
#define MEM_HALFWORD    3'b001
#define MEM_BYTE        3'b000

#define PTW_FETCH		2'b00
#define PTW_LOAD		2'b10
#define PTW_STORE		2'b11

module load_store_unit {
	reg cache_adrs[32];
	reg cache_wdata[32];
	reg cache_byteen[3];
	reg ptw_op[2];
	reg ptw_adrs[32];

	proc_name idle();
	proc_name flush_cache();
	proc_name read_cache(cache_adrs, cache_byteen);
	proc_name write_cache(cache_adrs, cache_byteen, cache_wdata);
	proc_name flush_tlb();
	proc_name page_table_walk(ptw_adrs, ptw_op);
	cache dcache;
	ptw walker;

	mem tlb_data[32][32];
	mem tlb_levels[32][2];
	mem tlb_valid[32] = {0};
	mem tlb_tag[32][20] = {0};
	reg tlb_random_replace_pos[5] = 0;

	wire va[32];
	func_self access_tlb(va);
	wire tlb_hit_data[32];
	wire tlb_hit_levels[2];
	func_self tlb_hit(tlb_hit_data, tlb_hit_levels);
	func_self tlb_miss();

	wire refill_tlb_tag[20];
	wire refill_tlb_data[32];
	wire refill_tlb_levels[2];
	func_self refill_tlb(refill_tlb_tag, refill_tlb_data, refill_tlb_levels);

	wire sv32;

	integer i_;

	tlb_random_replace_pos++;
	sv32 = (satp_mode && (priv_mode != MACHINE));

	func reset {
		dcache.reset();
		walker.reset();
		idle();
	}
	proc idle {
		sv32_pte_t wire sv32_pte;
		wire sv32_pa[32];
		sv32_va_t wire sv32_va;

		sv32_va = adrs;
		sv32_pte = tlb_hit_data;												/* valid on (tlb_hit) */
		if(sv32) {
			any {
				tlb_hit_levels == 0:	sv32_pa = {sv32_pte.ppn1[9:0], sv32_pte.ppn0, sv32_va.page_offset};	/* valid on (tlb_hit) */
				tlb_hit_levels == 1:	sv32_pa = {sv32_pte.ppn1[9:0], sv32_va.vpn0, sv32_va.page_offset};	/* valid on (tlb_hit) */
			}
		} else {
			sv32_pa = sv32_va;
		}

		alt {
			cache_flush: {
				dcache.cache_flush();
				flush_cache();		
			}
			tlb_flush: {
				flush_tlb();
			}
			load && sv32: {
				access_tlb(sv32_va);

				if(tlb_hit) {
					if(sv32_pte.v && (sv32_pte.r || (mstatus_mxr && sv32_pte.x)) && sv32_pte.a
						&& ((sv32_pte.u && ((priv_mode == USER) || ((priv_mode == SUPERVISOR) && sstatus_sum))) || (!sv32_pte.u && priv_mode != USER))) {
						dcache.read(sv32_pa, byteen);
						if(!dcache.load_access_fault) {
							read_cache(sv32_pa, byteen);
						}
					} else {
						load_page_fault();
					}
				}
				if(tlb_miss) {
					page_table_walk(sv32_va, PTW_LOAD);
				}
			}
			store && sv32: {
				access_tlb(sv32_va);

				if(tlb_hit) {
					if(sv32_pte.v && sv32_pte.r && sv32_pte.w && sv32_pte.a && sv32_pte.d
						&& ((sv32_pte.u && ((priv_mode == USER) || ((priv_mode == SUPERVISOR) && sstatus_sum))) || (!sv32_pte.u && priv_mode != USER))) {
						dcache.write(sv32_pa, byteen, store_data);	
						if(!dcache.store_amo_access_fault) {
							write_cache(sv32_pa, byteen, store_data);
						}
					} else {
						store_amo_page_fault();
					}
				}
				if(tlb_miss) {
					page_table_walk(sv32_va, PTW_STORE);
				}
#ifdef DEBUG
				if(sv32_pa == 0x80001000) {
					sim_done(store_data);
				}
#endif
			}
			load && !sv32: {
				dcache.read(sv32_pa, byteen);	
				if(!dcache.load_access_fault) {
					read_cache(sv32_pa, byteen);
				}
			}
			store && !sv32: {
				dcache.write(sv32_pa, byteen, store_data);	
				if(!dcache.store_amo_access_fault) {
					write_cache(sv32_pa, byteen, store_data);
				}
#ifdef DEBUG
				if(sv32_pa == 0x80001000) {
					sim_done(store_data);
				}
#endif
			}
			read_tlb: {
				access_tlb(tlb_adrs);

				if(tlb_hit) {
					pte = tlb_hit_data;
					pte_levels = tlb_hit_levels;
					pte_valid();
				}
				if(tlb_miss) {
					page_table_walk(tlb_adrs, PTW_FETCH);
				}
			}
		}
	}
	proc flush_cache {
		dcache.cache_flush();

		if(dcache.cache_flush_done) {
			cache_flush_done();
			idle();
		}
	}
	proc flush_tlb {
		generate(i_ = 0; i_ < 32; i_++) {
			tlb_valid[i_] := INVALID;
		}
		tlb_flush_done();
		idle();
	}
	proc read_cache {
		dcache.read(cache_adrs, cache_byteen);	

		if(dcache.valid) {
			load_data = dcache.rdata;
			valid();
			idle();
		}
		if(dcache.load_access_fault) {
			idle();
		}
	}
	proc write_cache {
		dcache.write(cache_adrs, cache_byteen, cache_wdata);	

		if(dcache.valid) {
			valid();
			idle();
		}
		if(dcache.store_amo_access_fault) {
			idle();
		}
	}
	proc page_table_walk {
		walker.walk({satp_mode, satp_asid, satp_ppn}, ptw_adrs);

		if(walker.pte_valid) {
			refill_tlb(ptw_adrs[31:12], walker.pte, walker.pte_levels);
			idle();
		}
		if(walker.page_fault) {
			any {
				ptw_op == PTW_FETCH:	read_tlb_page_fault();
				ptw_op == PTW_STORE:	store_amo_page_fault();
				ptw_op == PTW_LOAD:		load_page_fault();
			}
			idle();
		}
	}
	func walker.mem_read {
		dcache.read(walker.mem_adrs[31:0], MEM_WORD);	

		if(dcache.valid) {
			walker.mem_rdata = dcache.rdata[31:0];
			walker.mem_valid();
		}
	}
	func access_tlb {
		generate(i_ = 0; i_ < 32; i_++) {
			if(tlb_valid[i_] && (tlb_tag[i_] == va[31:12])) {
				tlb_hit(tlb_data[i_], tlb_levels[i_]);
			}
		}
		if(!tlb_hit) {
			tlb_miss();
		}
	}
	func refill_tlb {
		tlb_data[tlb_random_replace_pos] := refill_tlb_data;
		tlb_tag[tlb_random_replace_pos] := refill_tlb_tag;
		tlb_levels[tlb_random_replace_pos] := refill_tlb_levels;
		tlb_valid[tlb_random_replace_pos] := VALID;
	}
	func dcache.pma_check {
		pma_check(dcache.pma_adrs);
	}
	func pma_empty {
		dcache.pma_empty();
	}
	func pma_cacheable {
		dcache.pma_cacheable();
	}
	func dcache.mem_read {
		mem_read(dcache.mem_adrs, dcache.mem_size);
	}
	func dcache.mem_write {
		mem_write(dcache.mem_adrs, dcache.mem_size, dcache.mem_wdata);
	}
	func mem_valid {
		dcache.mem_rdata = mem_rdata;
		dcache.mem_valid();
	}
	func dcache.store_amo_access_fault {
		store_amo_access_fault();
	}
	func dcache.load_access_fault {
		any {
			page_table_walk && ptw_op == PTW_FETCH: read_tlb_access_fault();
			else: 									load_access_fault();
		}
	}
}

