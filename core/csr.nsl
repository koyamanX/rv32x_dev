#include "csr_map.h"
#include "csr.h"

module csr32{
	/* CSRs */
	/* Machine mode CSRs */
	mvendorid_t reg mvendorid		= 0;
	marchid_t reg marchid			= 0;
	mimpid_t reg mimpid				= 0;
	mhartid_t reg mhartid			= 0;
	mstatus_t reg mstatus			= 0;
	mstatush_t reg mstatush			= 0;
	mtvec_t reg mtvec 				= INIT_MTVEC;
	mscratch_t reg mscratch			= 0;
	mepc_t reg mepc					= 0;
	mcause_t reg mcause 			= RESET;
	mtval_t reg mtval				= 0;
	misa_t reg misa					= 0;
	mie_t reg mie					= 0;
	mip_t reg mip					= 0;
	mideleg_t reg mideleg			= 0;
	medeleg_t reg medeleg			= 0;
	/* Supervisor mode CSRs */
	sstatus_t reg sstatus			= 0;		
	sie_t reg sie					= 0;
	stvec_t reg stvec				= 0;
	sscratch_t reg sscratch			= 0;
	sepc_t reg sepc					= 0;
	scause_t reg scause				= 0;
	stval_t reg stval 				= 0;
	sip_t reg sip					= 0;
	satp_t reg satp					= 0;
	/* Hardware Performance Monitor */
	reg minstret[64]				= 0;
	reg mcycle[64]					= 0;
	reg utime[64]					= 0;

    mip_ = mip;
    mie_ = mie;
    sie_ = sie;
    satp_ = satp;
    mstatus_ = mstatus;
    sstatus_ = sstatus;
    mideleg_ = mideleg;
    medeleg_ = medeleg;

	if(!write) {	/* precisely, !((mcycle || minstret) && csr_write) */
		mcycle++;	/* if wfi, then stop counting up */
		if(instret) {
			minstret++;	/* not-precise, some instruction such as ecall will not retire */
		}
	}
	utime++;	/* if m_clock == 50MHz, then 1 tick is 20ns */

    func reset{
		mstatus.mie 				:= 0;
		mstatus.mprv 				:= 0;
		mstatush.mbe				:= 0;
		mstatus.mpp					:= MACHINE;
		misa.mxl 					:= MISA_MXL_32;
		misa.extensions 			:= MISA_EXTENSIONS;
		mcause 						:= RESET;
		mtvec 						:= INIT_MTVEC;
    }

    func trap_ret{
        if(mode == MACHINE){
			mtval := 0;
            mstatus.mie 	:= mstatus.mpie;
            mstatus.mpie	:= 1;
            mstatus.mpp		:= MACHINE;
            mstatus.mprv 	:= if(mstatus.mpp != MACHINE) 1'b0 else sstatus.mprv;
            sstatus.mprv 	:= if(mstatus.mpp != MACHINE) 1'b0 else sstatus.mprv;
            return mepc;
        }else{
			stval := 0;
            mstatus.sie		:= sstatus.spie;
            sstatus.sie		:= sstatus.spie;
            mstatus.spie	:= 1;
            sstatus.spie	:= 1;
            mstatus.mprv 	:= if(mstatus.mpp != MACHINE) 1'b0 else sstatus.mprv;
            sstatus.mprv 	:= if(mstatus.mpp != MACHINE) 1'b0 else sstatus.mprv;
            return sepc;
        }
    }

    func trap{
		mtvec_t wire tvec;

		any {
			trap_priv_mode == MACHINE: {
				mstatus.mpie 	:= mstatus.mie;
				mstatus.mie 	:= 0;
				mstatus.mpp 	:= priv_mode;
				mcause 			:= trap_cause;
				mepc 			:= trap_pc;
				mtval			:= trap_val;
				tvec 			= mtvec;
			}
			trap_priv_mode == SUPERVISOR: {
				mstatus.spp		:= priv_mode[0];
				sstatus.spp		:= priv_mode[0];
				mstatus.spie 	:= sstatus.sie;
				sstatus.spie 	:= sstatus.sie;
				mstatus.sie		:= 0;
				sstatus.sie		:= 0;
				scause			:= trap_cause;
				sepc			:= trap_pc;
				stval			:= trap_val;
				tvec			= stvec;
			}
		}

        return tvec;
    }

	func read {
		any {
			/* Machine-mode */
			(priv_mode >= MACHINE) && cradrs == MVENDORID:			return mvendorid;
			(priv_mode >= MACHINE) && cradrs == MARCHID:			return marchid;
			(priv_mode >= MACHINE) && cradrs == MIMPID:				return mimpid;
			(priv_mode >= MACHINE) && cradrs == MHARTID:			return mhartid;
			(priv_mode >= MACHINE) && cradrs == MSTATUS:			return mstatus;
			(priv_mode >= MACHINE) && cradrs == MISA:				return misa;
			(priv_mode >= MACHINE) && cradrs == MEDELEG:			return medeleg;
			(priv_mode >= MACHINE) && cradrs == MIDELEG:			return mideleg;
			(priv_mode >= MACHINE) && cradrs == MIE:				return mie;
			(priv_mode >= MACHINE) && cradrs == MTVEC:				return mtvec;
			//(priv_mode >= MACHINE) && cradrs == MCOUNTEREN:		return mcounteren;
			(priv_mode >= MACHINE) && cradrs == MSTATUSH:			return mstatush;
			(priv_mode >= MACHINE) && cradrs == MSCRATCH:			return mscratch;
			(priv_mode >= MACHINE) && cradrs == MEPC:				return mepc;
			(priv_mode >= MACHINE) && cradrs == MCAUSE:				return mcause;
			(priv_mode >= MACHINE) && cradrs == MTVAL:				return mtval;
			(priv_mode >= MACHINE) && cradrs == MIP:				return mip | 32'({meip, 1'b1, seip, 1'b0, mtip, 1'b0, stip, 1'b0, msip, 1'b0, ssip, 1'b0});
			//(priv_mode >= MACHINE) && cradrs == MTINST:			return mtinst;
			//(priv_mode >= MACHINE) && cradrs == MTVAL2:			return mtval2;
			/* Machine Memory Protection */
			/* Machine Counter/Timers */
			(priv_mode >= MACHINE) && cradrs == MCYCLEH:			return mcycle[63:32];
			(priv_mode >= MACHINE) && cradrs == MCYCLE:				return mcycle[31:0];
			(priv_mode >= MACHINE) && cradrs == MINSTRETH:			return minstret[63:32];
			(priv_mode >= MACHINE) && cradrs == MINSTRET:			return minstret[31:0];

			/* Supervisor-mode */
			(priv_mode >= SUPERVISOR) && cradrs == SSTATUS:			return sstatus;
			//(priv_mode >= SUPERVISOR) && cradrs == SEDELEG:		return sedeleg;
			//(priv_mode >= SUPERVISOR) && cradrs == SIDELEG:		return sideleg;
			(priv_mode >= SUPERVISOR) && cradrs == SIE:				return sie;
			(priv_mode >= SUPERVISOR) && cradrs == STVEC:			return stvec;
			//(priv_mode >= SUPERVISOR) && cradrs == SCOUNTEREN:	return scounteren;
			(priv_mode >= SUPERVISOR) && cradrs == SSCRATCH:		return sscratch;
			(priv_mode >= SUPERVISOR) && cradrs == SEPC:			return sepc;
			(priv_mode >= SUPERVISOR) && cradrs == SCAUSE:			return scause;
			(priv_mode >= SUPERVISOR) && cradrs == STVAL:			return stval;
			(priv_mode >= SUPERVISOR) && cradrs == SIP:				return sip;
			(priv_mode >= SUPERVISOR) && cradrs == SATP
				&& !((priv_mode == SUPERVISOR) && mstatus.tvm):		return satp;

			/* User-mode */
			//(priv_mode >= USER) && cradrs == FRM:					return frm;
			//(priv_mode >= USER) && cradrs == FCSR:				return fcsr;
			/* User Counter/Timers */
			(priv_mode >= USER) && cradrs == CYCLEH:				return mcycle[63:32];
			(priv_mode >= USER) && cradrs == CYCLE:					return mcycle[31:0];
			(priv_mode >= USER) && cradrs == INSTRETH:				return minstret[63:32];
			(priv_mode >= USER) && cradrs == INSTRET:				return minstret[31:0];
			(priv_mode >= USER) && cradrs == TIMEH:					return utime[63:32];
			(priv_mode >= USER) && cradrs == TIME:					return utime[31:0];
			else:							{read_not_mapped(); return 0x00000000;}
		}
	}
    
	func write {
		mstatus_t wire status_w; 
		mtvec_t  wire tvec_w;
		mip_t wire ip_w;
		mideleg_t wire ideleg_w;
		medeleg_t wire edeleg_w;
		mie_t wire ie_w;
		satp_t wire satp_w;

		any {
			(priv_mode >= MACHINE) && cwadrs == MSTATUS: {
				status_w = cwdata;
				
				//mstatus.sd	:= status_w.sd;
				mstatus.tsr		:= status_w.tsr;
				mstatus.tw		:= status_w.tw;
				mstatus.tvm		:= status_w.tvm;
				mstatus.mxr		:= status_w.mxr;
				sstatus.mxr		:= status_w.mxr;
				mstatus.sum		:= status_w.sum;
				sstatus.sum		:= status_w.sum;
				mstatus.mprv 	:= status_w.mprv;
				//mstatus.xs	:= status_w.xs;
				//mstatus.fs	:= status_w.fs;
				mstatus.mpp		:= if(status_w.mpp != HYPERVISOR) status_w.mpp else mstatus.mpp;
				mstatus.spp		:= status_w.spp;
				sstatus.spp		:= status_w.spp;
				mstatus.mpie 	:= status_w.mpie;
				//mstatus.ube 	:= status_w.ube;
				mstatus.spie	:= status_w.spie;
				sstatus.spie	:= status_w.spie;
				mstatus.mie		:= status_w.mie;
				mstatus.sie		:= status_w.sie;
				sstatus.sie		:= status_w.sie;
			}
			(priv_mode >= MACHINE) && cwadrs == MEDELEG: {
				edeleg_w = cwdata;

				medeleg.store_amo_page_fault := edeleg_w.store_amo_page_fault;
				medeleg.load_page_fault := edeleg_w.load_page_fault;
				medeleg.instruction_page_fault := edeleg_w.instruction_page_fault;
				medeleg.environment_call_from_m_mode := edeleg_w.environment_call_from_m_mode;
				medeleg.environment_call_from_s_mode := edeleg_w.environment_call_from_s_mode;
				medeleg.environment_call_from_u_mode := edeleg_w.environment_call_from_u_mode;
				medeleg.store_amo_access_fault := edeleg_w.store_amo_access_fault;
				medeleg.store_amo_address_misaligned := edeleg_w.store_amo_address_misaligned;
				medeleg.load_access_fault := edeleg_w.load_access_fault;
				medeleg.load_address_misaligned := edeleg_w.load_address_misaligned;
				medeleg.breakpoint := edeleg_w.breakpoint;
				medeleg.illegal_instruction := edeleg_w.illegal_instruction;
				medeleg.instruction_access_fault := edeleg_w.instruction_access_fault;
				medeleg.instruction_address_misaligned := edeleg_w.instruction_address_misaligned;
			}
			(priv_mode >= MACHINE) && cwadrs == MIDELEG: {
				ideleg_w = cwdata;

				mideleg.seip := ideleg_w.seip;
				mideleg.stip := ideleg_w.stip;
				mideleg.ssip := ideleg_w.ssip;
			}
			(priv_mode >= MACHINE) && cwadrs == MIE: {
				ie_w = cwdata;

				/* Machine mode */
				mie.meie := ie_w.meie;
				mie.mtie := ie_w.mtie;
				mie.msie := ie_w.msie;

				/* Supervisor mode */
				mie.seie := ie_w.seie;
				mie.stie := ie_w.stie;
				mie.ssie := ie_w.ssie;
				sie.seie := ie_w.seie;
				sie.stie := ie_w.stie;
				sie.ssie := ie_w.ssie;
			}
			(priv_mode >= MACHINE) && cwadrs == MTVEC: {
				tvec_w = cwdata;
				
				mtvec.base := tvec_w.base;
				if(tvec_w.mode < 2'b10) {
					mtvec.mode := tvec_w.mode;
				}
			}
			(priv_mode >= MACHINE) && cwadrs == MSTATUSH: {
				mstatush := cwdata & 0x00000000;
			}
			(priv_mode >= MACHINE) && cwadrs == MSCRATCH: {
				mscratch := cwdata;
			}
			(priv_mode >= MACHINE) && cwadrs == MEPC: {
				mepc := {cwdata[31:2], (cwdata[1:0] & ~ialign)};
			}
			(priv_mode >= MACHINE) && cwadrs == MCAUSE:	{
				mcause := mcause;
			}
			(priv_mode >= MACHINE) && cwadrs == MTVAL: {
				mtval := cwdata;
			}
			(priv_mode >= MACHINE) && cwadrs == MIP: {
				ip_w = cwdata;
				
				/* mip.meip, mip.mtip, mip.msip is read-only */
				/* Only interrupt controller can set or reset */
				/* Supervisor mode */
				mip.ssip := ip_w.ssip;
				mip.seip := ip_w.seip;
				mip.stip := ip_w.stip;
				sip.ssip := ip_w.ssip;
				sip.seip := ip_w.seip;
				sip.stip := ip_w.stip;
			}
			(priv_mode >= MACHINE) && cwadrs == MCYCLE:	{
				mcycle	:= {mcycle[63:32], cwdata};
			}
			(priv_mode >= MACHINE) && cwadrs == MINSTRET: {
				minstret := {minstret[63:32], cwdata};
			}
			(priv_mode >= MACHINE) && cwadrs == MCYCLEH: {
				mcycle	:= {cwdata, mcycle[31:0]};
			}
			(priv_mode >= MACHINE) && cwadrs == MINSTRETH: {
				minstret := {cwdata, minstret[31:0]};
			}
			(priv_mode >= SUPERVISOR) && cwadrs == SSTATUS: {
				status_w = cwdata;

				mstatus.sum		:= status_w.sum;
				sstatus.sum		:= status_w.sum;

				mstatus.mxr		:= status_w.mxr;
				sstatus.mxr		:= status_w.mxr;

				mstatus.sie		:= status_w.sie;
				mstatus.spie	:= status_w.spie;
				mstatus.spp		:= status_w.spp;

				sstatus.sie		:= status_w.sie;
				sstatus.spie	:= status_w.spie;
				sstatus.spp		:= status_w.spp;
			}
			(priv_mode >= SUPERVISOR) && cwadrs == STVEC: {
				tvec_w = cwdata;
				
				stvec.base := tvec_w.base;
				if(tvec_w.mode < 2'b10) {
					stvec.mode := tvec_w.mode;
				}
			}
			(priv_mode >= SUPERVISOR) && cwadrs == SIE: {
				ie_w = cwdata;
				
				mie.seie := ie_w.seie;
				mie.stie := ie_w.stie;
				mie.ssie := ie_w.ssie;
				sie.seie := ie_w.seie;
				sie.stie := ie_w.stie;
				sie.ssie := ie_w.ssie;
			}
			(priv_mode >= SUPERVISOR) && cwadrs == SIP: {
				ip_w = cwdata;

				mip.ssip := ip_w.ssip;
				sip.ssip := ip_w.ssip;
			}
			(priv_mode >= SUPERVISOR) && cwadrs == SATP
				&& !((priv_mode == SUPERVISOR) && (mstatus.tvm)): {
					satp_w = cwdata;

					satp.mode := satp_w.mode;
					satp.asid := satp_w.asid;
					satp.ppn := satp_w.ppn;
				}
			(priv_mode >= SUPERVISOR) && cwadrs == SSCRATCH: {
				sscratch := cwdata;
			}
			(priv_mode >= SUPERVISOR) && cwadrs == SEPC: {
				sepc := {cwdata[31:2], (cwdata[1:0] & ~ialign)};
			}
			(priv_mode >= SUPERVISOR) && cwadrs == SCAUSE: {
				scause := scause;
			}
			(priv_mode >= SUPERVISOR) && cwadrs == STVAL: {
				stval := cwdata;
			}
			else: write_not_mapped();
		}
	}
}