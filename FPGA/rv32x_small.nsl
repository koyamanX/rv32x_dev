#include "rv32x_small.h"
#include "rv32x_core.h"
#include "opcode.h"
#include "bootrom.h"
#include "memory_map.h"
#include "clint.h"
#include "plic.h"

module rv32x_small {
	rv32x_core core;
	bootrom rom;
	clint rv32x_clint;
	plic rv32x_plic;

	func reset {
		core.reset();
		rom.reset();
		rv32x_plic.reset();
	}
	/* Interconnect */
	func core.imem_read {
		any {
			/* BOOTROM_BASE <= rv32x.iaddr && */ core.iaddr < BOOTROM_BASE+BOOTROM_LENGTH: rom.read((core.iaddr-BOOTROM_BASE)[11:0], MEM_WORD);
			else: imem_read(core.iaddr, core.ibyteen);
		}
	}
	func core.dmem_read {
		any {
			CLINT_BASE <= core.daddr && core.daddr < CLINT_BASE + CLINT_LENGTH:	rv32x_clint.read((core.daddr - CLINT_BASE)[15:0]);
			PLIC_BASE <= core.daddr && core.daddr < PLIC_BASE + PLIC_LENGTH: rv32x_plic.read((core.daddr));
			else: dmem_read(core.daddr, core.dbyteen);
		}
	}
	func core.dmem_write {
		any {
			CLINT_BASE <= core.daddr && core.daddr < CLINT_BASE + CLINT_LENGTH:	rv32x_clint.write((core.daddr - CLINT_BASE)[15:0], core.wdata);
			PLIC_BASE <= core.daddr && core.daddr < PLIC_BASE + PLIC_LENGTH: rv32x_plic.write(core.daddr, core.wdata);
			else: dmem_write(core.daddr, core.dbyteen, core.wdata);
		}
	}
	/* End of Interconnect */

	/* PMA settings per hart */
	func core.imem_pma_check {
		any {
			/* BOOTROM_BASE <= rv32x.imem_pma_addr && */ core.imem_pma_addr < BOOTROM_BASE+BOOTROM_LENGTH: {
				core.imem_pma_executable();
				core.imem_pma_readable();
				core.imem_pma_word();
				core.imem_pma_halfword();
				core.imem_pma_cacheable();
			}
			SDRAM_BASE <= core.imem_pma_addr && core.imem_pma_addr < SDRAM_BASE + SDRAM_LENGTH: {
				core.imem_pma_executable();
				core.imem_pma_readable();
				core.imem_pma_word();
				core.imem_pma_halfword();
				core.imem_pma_cacheable();
			}
			else: core.imem_pma_empty();
		}
	}
	func core.dmem_pma_check {
		/* all location are mapped & cacheable for simulation purpose */
		any {
			CLINT_BASE <= core.dmem_pma_addr && core.dmem_pma_addr < CLINT_BASE + CLINT_LENGTH: {
				core.dmem_pma_writable();
				core.dmem_pma_readable();
				core.dmem_pma_atomic();
				core.dmem_pma_word();
			}
			PLIC_BASE <= core.dmem_pma_addr && core.dmem_pma_addr < PLIC_BASE + PLIC_LENGTH: {
				core.dmem_pma_writable();
				core.dmem_pma_readable();
				core.dmem_pma_atomic();
				core.dmem_pma_word();
			}
			SDRAM_BASE <= core.dmem_pma_addr && core.dmem_pma_addr < SDRAM_BASE + SDRAM_LENGTH: {
				core.dmem_pma_writable();
				core.dmem_pma_readable();
				core.dmem_pma_atomic();
				core.dmem_pma_word();
				core.dmem_pma_halfword();
				core.dmem_pma_byte();
				core.dmem_pma_cacheable();
			}
			else: core.dmem_pma_empty();
		}
	}
	/* BUS ready signals */
	func dmem_ready {
		core.rdata = rdata;
		core.dmem_ready();
	}
	func imem_ready {
		core.inst = inst;
		core.imem_ready();
	}
	func rom.ready {
		core.inst = rom.rdata;
		core.imem_ready();
	}
	func rv32x_plic.ready {
		core.rdata = rv32x_plic.rdata;
		core.dmem_ready();
	}
	func rv32x_clint.ready {
		core.rdata = rv32x_clint.rdata;
		core.dmem_ready();
	}
	/* BUS interrupt signals */
	func rv32x_clint.timer_interrupt_hart0 {
		core.machine_timer_interrupt_req();
	}
	func rv32x_clint.software_interrupt_hart0 {
		core.machine_software_interrupt_req();
	}
	func rv32x_plic.external_interrupt_hart_0 {
		core.machine_external_interrupt_req();
	}
	func rv32x_plic.external_interrupt_hart_1 {
		core.supervisor_external_interrupt_req();
	}
	
#ifdef RISCV_TESTS
	func core.sim_done {
		sim_done(core.tohost);
	}
#endif
}
