#include "rv32x_integration.h"
#include "mem_ctr.h"
#include "opcode.h"
#include "top_bram.h"

module top_bram {
	reg read_cnt[2] = 0;
	reg ptr[2] = 0;
	mem inst_block_buf[4][2];
	reg inst_buf[28];
    func_self reset();
	func_self conflict();
	func_self init_sseg();
	wire iaddr[32];
	wire ibyteen[3];
	func_self imem_read(iaddr, ibyteen);
	reg led[10] = 0;
	reg sw[10] = 0;
	reg cnt[10] = 0;
	mem sseg[6][7];
	mem encode[16][7];/*={0b1111110, 0b0110000, 0b1101101, 0b1111001,
						0b0110011, 0b1011011, 0b1011111, 0b1110000,
						0b1111111, 0b1111011, 0b1110111, 0b0011111,
						0b1001110, 0b0111101, 0b1001111, 0b1000111};*/
	reg res_flag = 0;

	rv32x_integration core;
    mem_ctr bram;
	
	sw := SW;
    core.SW = sw;
	bram.SW = sw;
	TXD = core.TXD;
	core.RXD = RXD;
	SCLK = core.SCLK;
	CS = core.CS;
	MOSI = core.MOSI;
	core.MISO = MISO;
	LEDR = led;
	HEX0 = sseg[0];
	HEX1 = sseg[1];
	HEX2 = sseg[2];
	HEX3 = sseg[3];
	HEX4 = sseg[4];
	HEX5 = sseg[5];

	if(~res_flag && sw[9]){
		res_flag := 1;
		reset();
	}

	func reset {
		//bram.reset();
		core.reset();
		init_sseg();
	}
	func init_sseg{	//avoid initial begin
		integer i;
		generate(i=0;i<6;i++){
			sseg[i] := 0b1111111;
		}
		encode[0] := 0b1000000;
		encode[1] := 0b1111001;
		encode[2] := 0b0100100;
		encode[3] := 0b0110000;
		encode[4] := 0b0011001;
		encode[5] := 0b0010010;
		encode[6] := 0b0000010;
		encode[7] := 0b1111000;
		encode[8] := 0b0000000;
		encode[9] := 0b0010000;
		encode[10] := 0b0001000;
		encode[11] := 0b0000011;
		encode[12] := 0b1000110;
		encode[13] := 0b0100001;
		encode[14] := 0b0000110;
		encode[15] := 0b0001110;
	}

	func imem_read{
		bram.read(iaddr, ibyteen, IMEM);
	}

	if(!conflict && (read_cnt != ptr)){
		imem_read({inst_buf,inst_block_buf[ptr],2'b00}, MEM_WORD);
		ptr++;
	}

	func core.imem_read {
		if(!conflict && (read_cnt == ptr)){
			imem_read(core.iaddr, core.ibyteen);
		}else{
			inst_buf := core.iaddr[31:4];
			inst_block_buf[read_cnt] := core.iaddr[3:2];
			read_cnt++;
		}
	}
	func core.dmem_read {
		conflict();
		bram.read(core.daddr, core.dbyteen, DMEM);
	}
	func core.dmem_write {
		conflict();
		bram.write(core.daddr, core.dbyteen, core.wdata);
	}
	func bram.iready {
		core.inst = bram.rdata;
		core.imem_ready();
	}
	func bram.dready {
		core.rdata = bram.rdata;
		core.dmem_ready();
	}
}