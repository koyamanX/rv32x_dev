#include "bram_ctr.h"
#include "ram_1p.h"
#include "opcode.h"

module bram_ctr {

	reg memory_byteen[3];
	reg memory_type[2];
	proc_name memory_read(memory_byteen, memory_type);
	proc_name memory_write();

	ram_1p memory[4];
	integer i;
	
	generate(i=0; i<4; i++){
		memory[i].clock = m_clock;
	}
	
	func read {
		generate(i=0;i<4;i++){
			memory[i].address = addr[14:2];
			memory[i].wren = READ;
		}
		memory_read(byteen,type);
		#ifdef CV
			debug_sseg_l12(addr[13:2]);
		#endif
	}

	func write {
		any {
			byteen == MEM_WORD: {
				generate(i=0;i<4;i++){
					memory[i].address = addr[14:2];
					memory[i].wren = WRITE;
					memory[i].data = wdata[((i+1)*8 - 1):i*8];
				}
			}
			byteen == MEM_HALFWORD: {
				generate(i=0;i<2;i++){
					memory[i].address = addr[14:2];
					memory[i].wren = WRITE;
					memory[i].data = wdata[((i+1)*8 - 1):i*8];
				}
			}
			byteen == MEM_BYTE: {
				generate(i=0;i<1;i++){
					memory[i].address = addr[14:2];
					memory[i].wren = WRITE;
					memory[i].data = wdata[((i+1)*8 - 1):i*8];
				}
			}
		}
		memory_write();
	}

	proc memory_read{
		any {
			memory_byteen == MEM_WORD: {
				rdata = {memory[3].q,memory[2].q,memory[1].q,memory[0].q};
			} 
			memory_byteen == MEM_HALFWORD: {
				rdata = {0x0000, memory[1].q, memory[0].q};
			} 
			memory_byteen == MEM_BYTE: {
				rdata = {0x000000, memory[0].q};
			} 
			memory_type == IMEM: {
				iready();
			}
			memory_type == DMEM: {
				dready();
			}
		}
		finish();
	}

	proc memory_write{
		dready();
		finish();
	}
}